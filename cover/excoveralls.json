{"source_files":[{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null],"name":"test/support/channel_case.ex","source":"defmodule Librecov.ChannelCase do\n  @moduledoc \"\"\"\n  This module defines the test case to be used by\n  channel tests.\n\n  Such tests rely on `Phoenix.ChannelTest` and also\n  imports other functionality to make it easier\n  to build and query models.\n\n  Finally, if the test case interacts with the database,\n  it cannot be async. For this reason, every test runs\n  inside a transaction which is reset at the beginning\n  of the test unless the test case is marked as async.\n  \"\"\"\n\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      # Import conveniences for testing with channels\n      use Phoenix.ChannelTest\n\n      alias Librecov.Repo\n      import Ecto.Query, only: [from: 2]\n\n      # The default endpoint for testing\n      @endpoint Librecov.Endpoint\n    end\n  end\n\n  setup _tags do\n    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Librecov.Repo)\n  end\nend"},{"coverage":[null,null,null,null,null,8,null,null,null,8,null,null],"name":"test/support/fixtures.ex","source":"defmodule Librecov.Fixtures do\n  @coverages_path Path.join(__DIR__, \"../fixtures/dummy-coverages.json\")\n  @coverages @coverages_path |> File.read!() |> Jason.decode!()\n\n  def dummy_coverages do\n    @coverages\n  end\n\n  def dummy_coverage do\n    Enum.at(dummy_coverages(), 0)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,0,null,null,null,18,18,null,0,null,null,null,null,null,null,null,null,0,null,null,null,18,0,0,null,null,null,null,null,null,18,null,null,null,null,0,null,null,null,null,null,0,null,null],"name":"web/controllers/auth_controller.ex","source":"defmodule Librecov.AuthController do\n  use Librecov.Web, :controller\n\n  alias Librecov.Authentication\n  alias Librecov.User\n  alias Librecov.Repo\n\n  def login(conn, _params) do\n    render(conn, \"login.html\", email: \"\", error: nil, can_signup: can_signup?())\n  end\n\n  def make_login(conn, %{\"login\" => %{\"email\" => email, \"password\" => password}}) do\n    if user = User.authenticate(Repo.get_by(User, email: email), password) do\n      login_if_confirmed(conn, user)\n    else\n      render(conn, \"login.html\",\n        email: email,\n        error: \"Wrong email or password\",\n        can_signup: can_signup?()\n      )\n    end\n  end\n\n  def make_login(conn, _params) do\n    render(conn, \"login.html\", email: \"\", error: \"You need to provide your email and password\")\n  end\n\n  defp login_if_confirmed(conn, user) do\n    if is_nil(user.confirmed_at) do\n      render(conn, \"login.html\",\n        email: user.email,\n        error: \"Please confirm your email\",\n        can_signup: can_signup?()\n      )\n    else\n      conn\n      |> Authentication.login(user)\n      |> redirect(to: NavigationHistory.last_path(conn, default: \"/\"))\n    end\n  end\n\n  defp can_signup?() do\n    Librecov.SettingsManager.get!().signup_enabled\n  end\n\n  def logout(conn, _params) do\n    conn\n    |> Authentication.logout()\n    |> redirect(to: auth_path(conn, :login))\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,96,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,32,null,32,null,null,null,6,null,null,null,4,null,null,null,38,null,null,null,54,null,null,null,42,null,null,null,34,34,null,null,0,null,29,null,null,5,5,null,null,null,null,null,null,null,null,null,5,null,5,5,null,null,null,null,null,null,5,25,25,null,null,null,null,null,null,6,6,null,null,null,null,null,4,4,4,4,null,null],"name":"web/models/build.ex","source":"defmodule Librecov.Build do\n  use Librecov.Web, :model\n\n  @git_defaults %{\n    \"branch\" => nil,\n    \"head\" => %{\"id\" => nil, \"committer_name\" => nil, \"committer_email\" => nil, \"message\" => nil}\n  }\n\n  import Ecto.Query\n\n  schema \"builds\" do\n    field(:build_number, :integer)\n    field(:previous_build_id, :integer)\n    field(:coverage, :float, default: 0.0)\n    field(:completed, :boolean, default: true)\n    field(:previous_coverage, :float)\n    field(:build_started_at, :utc_datetime_usec)\n\n    field(:commit_sha, :string)\n    field(:committer_name, :string)\n    field(:committer_email, :string)\n    field(:commit_message, :string)\n    field(:branch, :string, default: \"\")\n\n    field(:service_name, :string)\n    field(:service_job_id, :string)\n    field(:service_job_pull_request, :string)\n\n    belongs_to(:project, Librecov.Project)\n    has_many(:jobs, Librecov.Job)\n    has_one(:previous_build, Librecov.Build, foreign_key: :previous_build_id)\n\n    timestamps()\n  end\n\n  def previous(project_id, build_number, nil),\n    do: previous(project_id, build_number, \"\")\n\n  def previous(project_id, build_number, branch) do\n    query_for_project(project_id)\n    |> where([b], b.build_number < ^build_number and b.branch == ^branch)\n    |> order_by_build_number\n    |> first\n  end\n\n  def current_for_project(query, project) do\n    query |> for_project(project.id) |> where([b], not b.completed)\n  end\n\n  def last_for_project(query, project) do\n    query |> for_project(project.id) |> order_by_build_number |> first\n  end\n\n  def query_for_project(project_id) do\n    for_project(Librecov.Build, project_id)\n  end\n\n  def for_project(query, project_id) do\n    query |> where([b], b.project_id == ^project_id)\n  end\n\n  def order_by_build_number(query) do\n    query |> order_by([b], desc: b.build_number)\n  end\n\n  def normalize_params(params) when is_map(params) do\n    {git_info, params} = Map.pop(params, \"git\")\n    Map.merge(params, git_params(git_info))\n  end\n\n  def normalize_params(params), do: params\n\n  defp git_params(nil), do: %{}\n\n  defp git_params(params) do\n    params = Map.merge(@git_defaults, params)\n    params = Map.put(params, \"head\", Map.merge(@git_defaults[\"head\"], params[\"head\"]))\n\n    %{\n      \"branch\" => branch,\n      \"head\" => %{\n        \"id\" => commit_sha,\n        \"committer_name\" => committer_name,\n        \"committer_email\" => committer_email,\n        \"message\" => commit_message\n      }\n    } = params\n\n    result = %{\n      \"branch\" => branch || \"\",\n      \"commit_sha\" => commit_sha,\n      \"committer_name\" => committer_name,\n      \"committer_email\" => committer_email,\n      \"commit_message\" => commit_message\n    }\n\n    for {k, v} <- result, into: %{} do\n      v = if is_nil(v), do: v, else: String.trim(v)\n      {k, v}\n    end\n  end\n\n  def for_commit(project, %{\"branch\" => branch, \"head\" => %{\"id\" => sha}})\n      when is_binary(branch) and is_binary(sha) and byte_size(branch) > 0 and byte_size(sha) > 0 do\n    Librecov.Build\n    |> for_project(project.id)\n    |> where([b], b.branch == ^branch and b.commit_sha == ^sha)\n  end\n\n  def for_commit(_, _), do: nil\n\n  def compute_coverage(build) do\n    build.jobs\n    |> Enum.map(fn j -> j.coverage end)\n    |> Enum.reject(fn n -> is_nil(n) or n == 0 end)\n    |> Enum.min()\n  end\nend"},{"coverage":[null,null,null],"name":"web/views/profile_view.ex","source":"defmodule Librecov.ProfileView do\n  use Librecov.Web, :view\nend"},{"coverage":[null,null,null,null,null,null,0,null,null,null,17,16,null,1,null,null,null,null,16,16,null,0,null,null,null,null,null,null,null,1,null,null],"name":"lib/librecov/plug/authentication.ex","source":"defmodule Librecov.Plug.Authentication do\n  import Plug.Conn\n  import Phoenix.Controller, only: [redirect: 2, put_flash: 3]\n  import Librecov.Helpers.Authentication\n\n  def init(opts) do\n    opts\n  end\n\n  def call(conn, opts) do\n    if user_signed_in?(conn) do\n      check_admin(conn, opts)\n    else\n      redirect_with(conn, :info, \"Please login\", \"/login\")\n    end\n  end\n\n  defp check_admin(conn, opts) do\n    if current_user(conn).admin || !opts[:admin] do\n      conn\n    else\n      redirect_with(conn, :error, \"You are not authorized here.\", \"/\")\n    end\n  end\n\n  defp redirect_with(conn, flash_type, flash_message, path) do\n    conn\n    |> put_flash(flash_type, flash_message)\n    |> redirect(to: path)\n    |> halt\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,5,3,null,null,null,null,null,8,3,null,5,null,null,null,2,null,null,null],"name":"web/views/file_view.ex","source":"defmodule Librecov.FileView do\n  use Librecov.Web, :view\n\n  import Librecov.CommonView\n  import Scrivener.HTML\n\n  @max_length 20\n\n  def filters do\n    %{\n      \"changed\" => \"Changed\",\n      \"cov_changed\" => \"Coverage changed\",\n      \"covered\" => \"Covered\",\n      \"unperfect\" => \"Unperfect\"\n    }\n  end\n\n  def short_name(name) do\n    if String.length(name) < @max_length do\n      name\n    else\n      name\n      |> String.split(\"/\")\n      |> Enum.reverse()\n      |> Enum.reduce({[], 0}, fn s, {n, len} ->\n        if len + String.length(s) <= @max_length do\n          {[s | n], len + String.length(s)}\n        else\n          {[String.first(s) | n], len + 1}\n        end\n      end)\n      |> elem(0)\n      |> Enum.join(\"/\")\n    end\n  end\nend"},{"coverage":[null,null,null],"name":"web/views/integration_view.ex","source":"defmodule Librecov.IntegrationView do\n  use Librecov.Web, :view\nend"},{"coverage":[null,null,null,5,null,null,null,null,null,null,null],"name":"web/models/settings.ex","source":"defmodule Librecov.Settings do\n  use Librecov.Web, :model\n\n  schema \"settings\" do\n    field(:signup_enabled, :boolean, default: false)\n    field(:restricted_signup_domains, :string, default: \"\")\n    field(:default_project_visibility, :string)\n\n    timestamps()\n  end\nend"},{"coverage":[null,null,null],"name":"web/views/admin/shared_view.ex","source":"defmodule Librecov.Admin.SharedView do\n  use Librecov.Web, :view\nend"},{"coverage":[null,null,null,null,null,null,null,0,0,null,0,null,0,0,0,null,null,0,null,null,null,null,0,null,0,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,0,0,null,null,null,null,null,null,null,0,0,null,0,null,0,0,null,null,0,null,null,null,null,0,null,null,null,0,0,null,null,null,0,null,null,null,null,0,null,null],"name":"web/services/user_service.ex","source":"defmodule Librecov.UserService do\n  alias Librecov.User\n  alias Librecov.UserManager\n  alias Librecov.UserMailer\n  alias Librecov.Repo\n\n  def create_user(user_params, opts) do\n    options = [generate_password: opts[:invited?]]\n    changeset = UserManager.changeset(%User{}, user_params, options)\n\n    case Repo.insert(changeset) do\n      {:ok, user} = res ->\n        email = UserMailer.confirmation_email(user, opts ++ [registration: true])\n        Librecov.AppMailer.send(email)\n        res\n\n      err ->\n        err\n    end\n  end\n\n  def confirm_user(token) do\n    case Repo.get_by(User, confirmation_token: token) do\n      %User{unconfirmed_email: m} = user when not is_nil(m) ->\n        finalize_confirmation!(user)\n        {:ok, user, \"Your email has been confirmed successfully\"}\n\n      %User{} = user ->\n        {:ok, user, \"You are already confirmed.\"}\n\n      _ ->\n        {:error, \"Could not find the user to confirm\"}\n    end\n  end\n\n  defp finalize_confirmation!(user) do\n    UserManager.confirmation_changeset(user) |> Repo.update!()\n  end\n\n  def send_reset_password(email) do\n    case Repo.get_by(User, email: email) do\n      %User{} = user ->\n        UserManager.password_reset_changeset(user)\n        |> Repo.update!()\n        |> UserMailer.reset_password_email()\n        |> Librecov.AppMailer.send()\n\n        :ok\n\n      _ ->\n        :ok\n    end\n  end\n\n  def finalize_reset_password(%{\"password_reset_token\" => token} = params) do\n    case Repo.get_by(User, password_reset_token: token) do\n      %User{} = user ->\n        opts = [skip_password_validation: true, remove_reset_token: true]\n        UserManager.password_update_changeset(user, params, opts) |> Repo.update()\n\n      _ ->\n        {:error, :not_found}\n    end\n  end\n\n  def update_user(%{\"user\" => user_params}, user) do\n    redirect_path = Librecov.Router.Helpers.profile_path(Librecov.Endpoint, :show)\n    changeset = Librecov.UserManager.changeset(user, user_params)\n\n    case Librecov.Repo.update(changeset) do\n      {:ok, user} ->\n        send_confirmation_email_if_needed(user, changeset)\n        {:ok, user, redirect_path, update_flash_message(changeset)}\n\n      {:error, changeset} ->\n        {:error, user: user, changeset: changeset}\n    end\n  end\n\n  defp send_confirmation_email_if_needed(user, changeset) do\n    if email_changed?(changeset), do: send_confirmation_email(user)\n  end\n\n  defp send_confirmation_email(user) do\n    email = Librecov.UserMailer.confirmation_email(user)\n    Librecov.AppMailer.send(email)\n  end\n\n  defp update_flash_message(changeset) do\n    \"Your profile has been changed successfully.\" <>\n      if email_changed?(changeset), do: \" Please confirm your email.\", else: \"\"\n  end\n\n  defp email_changed?(changeset) do\n    not is_nil(Ecto.Changeset.get_change(changeset, :unconfirmed_email))\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,27,null,null,null,25,20,null,5,null,null,null,null,5,5,5,5,null,null,null,25,25,25,25,null,25,2,2,2,null,null,23,null,null,null,null,null,null,2,null,null,4,4,4,null,null,null,4,4,4,null,4,20,null,null,4,null,null],"name":"web/managers/job_manager.ex","source":"defmodule Librecov.JobManager do\n  use Librecov.Web, :manager\n\n  import Ecto.Query\n  import Librecov.Job\n  alias Librecov.Job\n  alias Librecov.FileManager\n\n  @required_fields ~w(build_id)a\n  @optional_fields ~w(run_at job_number files_count)a\n\n  def changeset(model, params \\\\ :invalid) do\n    model\n    |> cast(params, @required_fields ++ @optional_fields)\n    |> validate_required(@required_fields)\n    |> prepare_changes(&check_job_number/1)\n    |> prepare_changes(&set_previous_values/1)\n  end\n\n  defp check_job_number(changeset) do\n    if get_change(changeset, :job_number) do\n      changeset\n    else\n      set_job_number(changeset)\n    end\n  end\n\n  defp set_job_number(changeset) do\n    build_id = get_change(changeset, :build_id) || changeset.data.build_id\n    job = Job |> for_build(build_id) |> order_by(desc: :job_number) |> Repo.first()\n    job_number = if job, do: job.job_number + 1, else: 1\n    put_change(changeset, :job_number, job_number)\n  end\n\n  defp set_previous_values(changeset) do\n    build_id = get_change(changeset, :build_id) || changeset.data.build_id\n    job_number = get_change(changeset, :job_number)\n    previous_build_id = Librecov.Repo.get!(Librecov.Build, build_id).previous_build_id\n    previous_job = search_previous_job(previous_build_id, job_number)\n\n    if previous_job do\n      change(changeset, %{\n        previous_job_id: previous_job.id,\n        previous_coverage: previous_job.coverage\n      })\n    else\n      changeset\n    end\n  end\n\n  defp search_previous_job(nil, _), do: nil\n\n  defp search_previous_job(previous_build_id, job_number),\n    do: Job |> for_build(previous_build_id) |> where(job_number: ^job_number) |> Repo.first()\n\n  def update_coverage(job) do\n    job = change(job, coverage: compute_coverage(job)) |> Repo.update!() |> Repo.preload(:build)\n    Librecov.BuildManager.update_coverage(job.build)\n    job\n  end\n\n  def create_from_json!(build, params) do\n    {source_files, params} = Map.pop(params, \"source_files\", [])\n    params = Map.put(params, \"files_count\", Enum.count(source_files))\n    job = Ecto.build_assoc(build, :jobs) |> changeset(params) |> Repo.insert!()\n\n    Enum.each(source_files, fn file_params ->\n      Ecto.build_assoc(job, :files) |> FileManager.changeset(file_params) |> Repo.insert!()\n    end)\n\n    job |> Repo.preload(:files) |> update_coverage\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,72,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,2,null,null,2,null,null,null,0,null,0,0,null,0,null,null,null,null,null,4,null,1,3,4,null,4,5,null,null,1,null,null,null,null,null,1,null,null,1,1,0,null,null,1,null,null,null,0,null,null,null,40,null,40,null,33,null,null,null,40,null,null,33,null],"name":"web/models/file.ex","source":"defmodule Librecov.File do\n  use Librecov.Web, :model\n\n  import Ecto.Query\n\n  defimpl Jason.Encoder, for: Librecov.File do\n    def encode(model, opts) do\n      model\n      |> Map.take([:name, :source])\n      |> Map.put(:coverage, model.coverage_lines)\n      |> Jason.Encoder.encode(opts)\n    end\n  end\n\n  alias Librecov.Job\n\n  schema \"files\" do\n    field(:name, :string)\n    field(:source, :string)\n    field(:coverage, :float)\n    field(:previous_coverage, :float)\n    field(:coverage_lines, :map)\n\n    belongs_to(:job, Job)\n    belongs_to(:previous_file, Librecov.File)\n\n    timestamps()\n  end\n\n  @allowed_sort_fields ~w(name coverage diff)\n\n  def sort_by(query, param, order) when order in ~w(asc desc),\n    do: sort_by(query, param, String.to_atom(order))\n\n  def sort_by(query, param, order) when param in @allowed_sort_fields,\n    do: sort_by(query, String.to_atom(param), order)\n\n  def sort_by(query, :diff, order) do\n    query |> order_by([f], [{^order, fragment(\"abs(? - ?)\", f.previous_coverage, f.coverage)}])\n  end\n\n  def sort_by(query, param, order) do\n    order =\n      if __schema__(:type, param) == :string,\n        do: order,\n        else: reverse_order(order)\n\n    query |> order_by([f], [{^order, field(f, ^param)}])\n  end\n\n  # defp reverse_order(:asc), do: :desc\n  # defp reverse_order(:desc), do: :asc\n\n  def for_job(query \\\\ Librecov.File, job)\n\n  def for_job(query, jobs) when is_list(jobs), do: query |> where([f], f.job_id in ^jobs)\n  def for_job(query, %Librecov.Job{id: job_id}), do: for_job(query, job_id)\n  def for_job(query, job_id), do: query |> where([f], f.job_id == ^job_id)\n\n  def with_filters(query, [filter | rest]), do: with_filters(with_filter(query, filter), rest)\n  def with_filters(query, []), do: query\n\n  def with_filter(query, \"cov_changed\") do\n    query |> where([f], f.coverage != f.previous_coverage)\n  end\n\n  def with_filter(query, \"changed\") do\n    query\n    |> join(:left, [f], of in assoc(f, :previous_file))\n    |> where([f, of], f.source != of.source or is_nil(of.source))\n  end\n\n  def with_filter(query, \"covered\"), do: query |> where([f], f.coverage > 0.0)\n  def with_filter(query, \"unperfect\"), do: query |> where([f], f.coverage < 100.0)\n  def with_filter(query, _), do: query\n\n  def with_name(query, name) do\n    query |> where(name: ^name)\n  end\n\n  def order_by_coverage(query, order \\\\ :desc) do\n    query |> order_by([f], [{^order, f.coverage}])\n  end\n\n  def compute_coverage(lines) do\n    relevant_count = relevant_lines_count(lines)\n\n    if relevant_count == 0,\n      do: 0.0,\n      else: covered_lines_count(lines) * 100 / relevant_count\n  end\n\n  def relevant_lines_count(lines),\n    do: lines |> Enum.reject(fn n -> is_nil(n) end) |> Enum.count()\n\n  def covered_lines_count(lines),\n    do: lines |> Enum.reject(fn n -> is_nil(n) or n == 0 end) |> Enum.count()\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,8,null,1,null,7,7,null,null,8,8,8,8,null,null,null,0,null,null,3,null,null,7,null,null,1,null,null,1,null,1,1,null,1,null,1,null,1,1,null,null,0,null,null,null,null,1,1,1,null,null,null,null,null,null,8,null,null,7,7,1,0,0,null,null,8,null,null,null,null,null,null,null,null,null],"name":"lib/librecov/badge_creator.ex","source":"defmodule Librecov.BadgeCreator do\n  require EEx\n\n  # values and SVG are taken from https://github.com/badges/shields\n  @base_width 89\n  @extra_width 7\n  @template_path Path.join(__DIR__, \"templates/badge_template.eex\")\n  @authorized_formats ~w(png jpg svg)\n\n  EEx.function_from_file(:defp, :template, @template_path, [\n    :coverage_str,\n    :width,\n    :extra_width,\n    :bg_color\n  ])\n\n  def make_badge(coverage, options \\\\ []) do\n    {coverage, coverage_str, digits_num} =\n      if is_nil(coverage) do\n        {nil, \"NA\", 2}\n      else\n        coverage = round(coverage)\n        {coverage, \"#{coverage}%\", coverage |> Integer.to_string() |> String.length()}\n      end\n\n    extra_width = (digits_num - 1) * @extra_width\n    width = @base_width + extra_width\n    color = badge_color(coverage)\n    template(coverage_str, width, extra_width, color) |> get_image(options[:format])\n  end\n\n  defp get_image(svg, nil),\n    do: get_image(svg, \"png\")\n\n  defp get_image(svg, format) when format in @authorized_formats,\n    do: get_image(svg, String.to_atom(format))\n\n  defp get_image(svg, :svg),\n    do: {:ok, :svg, svg}\n\n  defp get_image(svg, format) when is_atom(format),\n    do: transform(svg, format)\n\n  def transform(svg, format) do\n    dir = Temp.mkdir!(\"librecov\")\n\n    {svg_path, output_path} =\n      {Path.join(dir, \"coverage.svg\"), Path.join(dir, \"coverage.#{format}\")}\n\n    File.write!(svg_path, svg)\n\n    case make_output(svg_path, output_path) do\n      {:ok, output} ->\n        File.rm_rf!(dir)\n        {:ok, format, output}\n\n      e ->\n        e\n    end\n  end\n\n  defp make_output(svg_path, output_path) do\n    try do\n      Librecov.ImageMagick.convert([svg_path, output_path])\n      File.read(output_path)\n    rescue\n      ErlangError -> {:error, \"failed to run convert\"}\n    end\n  end\n\n  defp badge_color(coverage) do\n    color =\n      cond do\n        is_nil(coverage) -> \"lightgrey\"\n        coverage == 0 -> \"red\"\n        coverage < 80 -> \"yellow\"\n        coverage < 90 -> \"yellowgreen\"\n        coverage < 100 -> \"green\"\n        true -> \"brightgreen\"\n      end\n\n    hex_color(color)\n  end\n\n  defp hex_color(\"red\"), do: \"#e05d44\"\n  defp hex_color(\"yellow\"), do: \"#dfb317\"\n  defp hex_color(\"yellowgreen\"), do: \"#a4a61d\"\n  defp hex_color(\"green\"), do: \"#97CA00\"\n  defp hex_color(\"brightgreen\"), do: \"#4c1\"\n  defp hex_color(\"lightgrey\"), do: \"#9f9f9f\"\nend"},{"coverage":[null,null,null,null,null],"name":"web/views/build_view.ex","source":"defmodule Librecov.BuildView do\n  use Librecov.Web, :view\n\n  import Librecov.CommonView\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,13,null,null,null,8,5,3,null,null,null,null,3,1,2,null,null,null,7,7,0,null,null,null,null,5,5,null,null,null,5,null,null,null,null,8,null,null,2,2,2,null,null,null],"name":"web/managers/badge_manager.ex","source":"defmodule Librecov.BadgeManager do\n  use Librecov.Web, :manager\n\n  alias Librecov.Badge\n  alias Librecov.BadgeCreator\n\n  import Librecov.Badge\n\n  @required_fields ~w(image format project_id)a\n  @optional_fields ~w(coverage)a\n\n  def changeset(model, params \\\\ :invalid) do\n    model\n    |> cast(params, @required_fields ++ @optional_fields)\n    |> validate_required(@required_fields)\n  end\n\n  def get_or_create(project, format \\\\ default_format()) do\n    case find(project.id, format) do\n      nil -> create(project, format)\n      badge -> return_or_update(project, badge)\n    end\n  end\n\n  defp return_or_update(project, badge) do\n    if project.current_coverage == badge.coverage,\n      do: {:ok, badge},\n      else: update(project, badge)\n  end\n\n  defp make(project, format, cb) do\n    case BadgeCreator.make_badge(project.current_coverage, format: format) do\n      {:ok, _format, image} -> {:ok, cb.(image)}\n      {:error, e} -> {:error, e}\n    end\n  end\n\n  defp create(project, format) do\n    make(project, format, fn image ->\n      params = %{image: image, format: to_string(format), coverage: project.current_coverage}\n\n      Ecto.build_assoc(project, :badge)\n      |> changeset(params)\n      |> Repo.insert!()\n    end)\n  end\n\n  defp find(project, format),\n    do: Badge |> for_project(project) |> with_format(format) |> Repo.first()\n\n  defp update(project, badge) do\n    make(project, badge.format, fn image ->\n      changeset(badge, %{coverage: project.current_coverage, image: image})\n      |> Repo.update!()\n    end)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,2,1,null,1,null,null,null,null,null,1,null,null,null,1,1,null,0,null,1,null,null],"name":"web/managers/settings_manager.ex","source":"defmodule Librecov.SettingsManager do\n  use Librecov.Web, :manager\n\n  @required_fields ~w()a\n  @optional_fields ~w(restricted_signup_domains signup_enabled default_project_visibility)a\n\n  def changeset(model, params \\\\ :invalid) do\n    model\n    |> cast(params, @required_fields ++ @optional_fields)\n    |> validate_required(@required_fields)\n    |> validate_inclusion(:default_project_visibility, Librecov.Project.visibility_choices())\n    |> normalize_domains\n  end\n\n  defp normalize_domains(changeset) do\n    if domains = get_change(changeset, :restricted_signup_domains) do\n      put_change(changeset, :restricted_signup_domains, String.trim(domains))\n    else\n      changeset\n    end\n  end\n\n  def get!() do\n    # TODO: cache the value\n    Librecov.Repo.first!(Librecov.Settings)\n  end\n\n  def restricted_signup_domains do\n    domains =\n      get!().restricted_signup_domains\n      |> String.split()\n      |> Enum.filter(&String.contains?(&1, \".\"))\n\n    if Enum.count(domains) > 0, do: domains, else: nil\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,34,null,null,null,4,4,4,null,null,null,4,4,null,4,0,4,null,null,null,4,4,4,4,null,null,null,34,0,34,null,null,null,null,6,null,null,6,6,null,null,null,32,null,32,3,3,3,null,null,29,null,null,null,null,null,null,null,null,null,32,null,null],"name":"web/managers/build_manager.ex","source":"defmodule Librecov.BuildManager do\n  use Librecov.Web, :manager\n\n  alias Librecov.Build\n  import Librecov.Build\n\n  @required_fields ~w(build_number)a\n  @optional_fields ~w(commit_sha commit_message committer_name committer_email branch\n                      service_name service_job_id service_job_pull_request project_id completed)a\n\n  def changeset(model, params \\\\ :invalid) do\n    model\n    |> cast(normalize_params(params), @required_fields ++ @optional_fields)\n    |> validate_required(@required_fields)\n    |> set_build_started_at\n    |> prepare_changes(&add_previous_values/1)\n  end\n\n  def create_from_json!(project, params) do\n    params = Map.merge(params, info_for(project, params))\n    build = Ecto.build_assoc(project, :builds)\n    Repo.insert!(changeset(build, params))\n  end\n\n  def get_or_create!(project, params) do\n    current_build = current_for_project(Build, project) |> Repo.first()\n    git_params = Map.get(params, \"git\", %{})\n\n    if build = current_build || Repo.first(for_commit(project, git_params)),\n      do: build,\n      else: create_from_json!(project, params)\n  end\n\n  def update_coverage(build) do\n    coverage = build |> Repo.preload(:jobs) |> compute_coverage\n    build = Repo.update!(change(build, coverage: coverage))\n    Librecov.ProjectManager.update_coverage(Repo.preload(build, :project).project)\n    build\n  end\n\n  defp set_build_started_at(changeset) do\n    if get_change(changeset, :build_started_at),\n      do: changeset,\n      else: put_change(changeset, :build_started_at, DateTime.utc_now())\n  end\n\n  # TODO: fetch build/job numbers from CI APIs\n  # def info_for(_project, %{\"service_name\" => \"travis-ci\"}), do: %{\"build_number\" => 1, \"job_number\" => 1}\n  def info_for(project, params), do: fallback_info_for(project, params)\n\n  defp fallback_info_for(project, _params) do\n    build = query_for_project(project.id) |> order_by_build_number |> Repo.first()\n    if build, do: %{\"build_number\" => build.build_number + 1}, else: %{\"build_number\" => 1}\n  end\n\n  defp add_previous_values(changeset) do\n    project_id = changeset.data.project_id || get_change(changeset, :project_id)\n\n    if previous_build = search_previous_build(changeset, project_id) do\n      change(changeset, %{\n        previous_build_id: previous_build.id,\n        previous_coverage: previous_build.coverage\n      })\n    else\n      changeset\n    end\n  end\n\n  defp search_previous_build(changeset, project_id) do\n    Build.previous(\n      project_id,\n      get_change(changeset, :build_number),\n      get_change(changeset, :branch)\n    )\n    |> Librecov.Repo.first()\n  end\nend"},{"coverage":[null,null,null,null,0,0,null,null],"name":"web/controllers/integration_controller.ex","source":"defmodule Librecov.IntegrationController do\n  use Librecov.Web, :controller\n\n  def show(conn, _params) do\n    user = current_user(conn) |> Librecov.External.GitHub.add_user_info()\n    render(conn, \"show.html\", user: user)\n  end\nend"},{"coverage":[null,null,null,null,null,null,0,null,null,null,38,19,null,19,null,null,null,null,19,null,19,19,null,0,null,null,null,null,0,null,null,null,null,null,null],"name":"lib/librecov/plug/force_password_initialize.ex","source":"defmodule Librecov.Plug.ForcePasswordInitialize do\n  import Librecov.Helpers.Authentication\n  import Plug.Conn, only: [halt: 1]\n  import Phoenix.Controller, only: [redirect: 2]\n\n  def init(opts) do\n    opts\n  end\n\n  def call(conn, _opts) do\n    if user_signed_in?(conn) do\n      check_password_state(conn)\n    else\n      conn\n    end\n  end\n\n  defp check_password_state(conn) do\n    user = current_user(conn)\n\n    if user.password_initialized or allowed_path?(conn) do\n      conn\n    else\n      redirect(conn, to: Librecov.Router.Helpers.profile_path(conn, :edit_password)) |> halt\n    end\n  end\n\n  defp allowed_path?(conn) do\n    conn.request_path in [\n      Librecov.Router.Helpers.profile_path(conn, :edit_password),\n      Librecov.Router.Helpers.profile_path(conn, :update_password),\n      Librecov.Router.Helpers.auth_path(conn, :logout)\n    ]\n  end\nend"},{"coverage":[null,null,null,38,null,null,null,null,null,null,null,null,null,null,null,null,null,null,18,null,null,null,17,null,null,null,0,null,null,null,5,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,0,18,null,0,0,0,0,0,null,null,null,null,null,null,0,null,1,null,0,0,0,0,null,0,0,0,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,0,null,null],"name":"web/router.ex","source":"defmodule Librecov.Router do\n  use Librecov.Web, :router\n\n  pipeline :browser do\n    plug(:accepts, [\"html\"])\n    plug(:fetch_session)\n    plug(:fetch_flash)\n    plug(:protect_from_forgery)\n    plug(:put_secure_browser_headers)\n    plug(Librecov.Plug.FetchUser)\n    plug(Librecov.Plug.ForcePasswordInitialize)\n    plug(NavigationHistory.Tracker, excluded_paths: ~w(/login /users/new))\n\n    if Application.get_env(:librecov, :auth)[:enable] do\n      plug(BasicAuth, use_config: {:librecov, :auth})\n    end\n  end\n\n  pipeline :anonymous_only do\n    plug(Librecov.Plug.AnonymousOnly)\n  end\n\n  pipeline :authenticate do\n    plug(Librecov.Plug.Authentication)\n  end\n\n  pipeline :authenticate_admin do\n    plug(Librecov.Plug.Authentication, admin: true)\n  end\n\n  pipeline :api do\n    plug(:accepts, [\"json\"])\n  end\n\n  scope \"/api/v1\", Librecov.Api.V1, as: :api_v1 do\n    pipe_through(:api)\n\n    resources(\"/jobs\", JobController, only: [:create])\n  end\n\n  scope \"/\", Librecov do\n    pipe_through(:browser)\n\n    get(\"/projects/:project_id/badge.:format\", ProjectController, :badge, as: :project_badge)\n  end\n\n  scope \"/\", Librecov do\n    pipe_through(:browser)\n    pipe_through(:anonymous_only)\n\n    get(\"/login\", AuthController, :login)\n    post(\"/login\", AuthController, :make_login)\n    resources(\"/users\", UserController, only: [:new, :create])\n    get(\"/users/confirm\", UserController, :confirm)\n    get(\"/profile/password/reset_request\", ProfileController, :reset_password_request)\n    post(\"/profile/password/reset_request\", ProfileController, :send_reset_password)\n    get(\"/profile/password/reset\", ProfileController, :reset_password)\n    put(\"/profile/password/reset\", ProfileController, :finalize_reset_password)\n  end\n\n  scope \"/\", Librecov do\n    pipe_through(:browser)\n    pipe_through(:authenticate)\n\n    delete(\"/logout\", AuthController, :logout)\n\n    get(\"/\", ProjectController, :index)\n\n    get(\"/profile\", ProfileController, :show)\n    put(\"/profile\", ProfileController, :update)\n    get(\"/profile/password/edit\", ProfileController, :edit_password)\n    put(\"/profile/password\", ProfileController, :update_password)\n\n    get(\"/integrations\", IntegrationController, :show)\n    get(\"/integrations/github/new\", Integration.GithubController, :new)\n    delete(\"/integrations/github\", Integration.GithubController, :delete)\n    get(\"/integrations/github/callback\", Integration.GithubController, :callback)\n\n    resources(\"/projects\", ProjectController)\n    resources(\"/builds\", BuildController, only: [:show])\n    resources(\"/files\", FileController, only: [:show])\n\n    resources(\"/jobs\", JobController, only: [:show])\n  end\n\n  scope \"/admin\", Librecov.Admin, as: :admin do\n    pipe_through(:browser)\n    pipe_through(:authenticate_admin)\n\n    get(\"/\", DashboardController, :index)\n\n    resources(\"/users\", UserController)\n    resources(\"/projects\", ProjectController, only: [:index, :show])\n    get(\"/settings\", SettingsController, :edit)\n    put(\"/settings\", SettingsController, :update)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,10,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,35,null,null],"name":"test/support/conn_case.ex","source":"defmodule Librecov.ConnCase do\n  @moduledoc \"\"\"\n  This module defines the test case to be used by\n  tests that require setting up a connection.\n\n  Such tests rely on `Phoenix.ConnTest` and also\n  imports other functionality to make it easier\n  to build and query models.\n\n  Finally, if the test case interacts with the database,\n  it cannot be async. For this reason, every test runs\n  inside a transaction which is reset at the beginning\n  of the test unless the test case is marked as async.\n  \"\"\"\n\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      # Import conveniences for testing with connections\n      use Phoenix.ConnTest\n\n      alias Librecov.Repo\n      import Ecto.Query, only: [from: 2]\n      import Librecov.Factory\n\n      import Librecov.Router.Helpers\n\n      # The default endpoint for testing\n      @endpoint Librecov.Endpoint\n\n      def with_login(conn) do\n        password = \"foobar123\"\n\n        user =\n          build(:user)\n          |> Librecov.Factory.confirmed_user()\n          |> Librecov.Factory.with_secure_password(password)\n          |> Librecov.Repo.insert!()\n\n        post(\n          conn,\n          auth_path(conn, :login, %{\"login\" => %{\"email\" => user.email, \"password\" => password}})\n        )\n      end\n    end\n  end\n\n  setup _tags do\n    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Librecov.Repo)\n  end\nend"},{"coverage":[null,null,null,null,null,null,0,0,0,0,null,null],"name":"web/controllers/admin/dashboard_controller.ex","source":"defmodule Librecov.Admin.DashboardController do\n  use Librecov.Web, :controller\n\n  alias Librecov.Repo\n\n  def index(conn, _params) do\n    users = Repo.latest(Librecov.User)\n    projects = Repo.latest(Librecov.Project)\n    settings = Librecov.SettingsManager.get!()\n    render(conn, \"index.html\", users: users, projects: projects, settings: settings)\n  end\nend"},{"coverage":[null,null,null,43,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,1,0,null,null,18,null,null],"name":"web/models/user.ex","source":"defmodule Librecov.User do\n  use Librecov.Web, :model\n\n  schema \"users\" do\n    field(:email, :string)\n    field(:admin, :boolean, default: false)\n    field(:name, :string)\n    field(:password_initialized, :boolean, default: true)\n    field(:confirmation_token, :string)\n    field(:confirmed_at, :utc_datetime_usec)\n    field(:unconfirmed_email, :string)\n\n    field(:github_access_token)\n    field(:github_info, :map, virtual: true)\n\n    field(:password_reset_token, :string)\n    field(:password_reset_sent_at, :utc_datetime_usec)\n\n    field(:current_password, :string, virtual: true)\n    field(:password, :string, virtual: true)\n    field(:password_confirmation, :string, virtual: true)\n    field(:password_digest, :string)\n\n    has_many(:projects, Librecov.Project)\n\n    timestamps()\n  end\n\n  @doc \"\"\"\n  Checks if the model password if valid.\n  \"\"\"\n  def authenticate(nil, _), do: Comeonin.Bcrypt.dummy_checkpw()\n  def authenticate(%{password_digest: nil}, _), do: Comeonin.Bcrypt.dummy_checkpw()\n  def authenticate(model, nil), do: authenticate(model, \"\")\n\n  def authenticate(model, password) do\n    Comeonin.Bcrypt.checkpw(password, model.password_digest) && model\n  end\nend"},{"coverage":[null,null,null,null,0,null,null,null,38,19,null,19,null,null,null,null,38,19,null,null,null],"name":"lib/librecov/plug/fetch_user.ex","source":"defmodule Librecov.Plug.FetchUser do\n  import Plug.Conn\n\n  def init(opts) do\n    opts\n  end\n\n  def call(conn, _opts) do\n    if user = current_user(conn) do\n      %{conn | assigns: Map.put(conn.assigns, :current_user, user)}\n    else\n      conn\n    end\n  end\n\n  defp current_user(conn) do\n    if user_id = get_session(conn, Librecov.Authentication.user_id_key()) do\n      Librecov.Repo.get(Librecov.User, user_id)\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,124,null,null,null,124,null,null,14,null,null,null,14,null,null],"name":"lib/librecov/repo.ex","source":"defmodule Librecov.Repo do\n  use Ecto.Repo, otp_app: :librecov, adapter: Ecto.Adapters.Postgres\n  use Scrivener, page_size: 10\n\n  require Ecto.Query\n  alias Ecto.Query\n\n  def latest(model, opts \\\\ []) do\n    all(\n      Query.from(m in model,\n        select: m,\n        limit: ^Keyword.get(opts, :limit, 5),\n        order_by: [desc: field(m, ^Keyword.get(opts, :order, :inserted_at))]\n      )\n    )\n  end\n\n  def first(queryable, opts \\\\ [])\n  def first(nil, _opts), do: nil\n\n  def first(queryable, opts) do\n    queryable |> Ecto.Query.first() |> one(opts)\n  end\n\n  def first!(queryable, opts \\\\ [])\n  def first!(nil, _opts), do: nil\n\n  def first!(queryable, opts) do\n    queryable |> Ecto.Query.first() |> one!(opts)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,8,null,null,null,8,null,8,null,null,null,null,null,24,null,null,null,null,8,8,8,null,null,null,8,null,0,8,null,null,8,8,null,null,null,16,16,null,null],"name":"web/views/form_helpers.ex","source":"defmodule Librecov.FormHelpers do\n  import Librecov.ErrorHelpers\n  import Phoenix.HTML.Tag\n  import Phoenix.HTML.Form\n\n  @input_default_opts [label: [], type: :text_input, attrs: [], args: []]\n\n  def form_group(form, field, do: block) do\n    content_tag(:div, block, class: \"form-group #{state_class(form, field)}\")\n  end\n\n  def input(form, field, opts \\\\ []) do\n    opts = Keyword.merge(@input_default_opts, opts)\n\n    form_group form, field do\n      [\n        make_label_tag(form, field, opts),\n        make_input_tag(form, field, opts),\n        error_tag(form, field)\n      ]\n      |> Enum.reject(&is_nil/1)\n    end\n  end\n\n  defp make_label_tag(form, field, opts) do\n    scope = to_string(opts[:scope] || form.name)\n    text = Gettext.dgettext(Librecov.Gettext, scope, to_string(field))\n    label(form, field, text, add_class(opts[:label], \"form-label\"))\n  end\n\n  defp make_input_tag(form, field, opts) do\n    {mod, fun} =\n      case opts[:type] do\n        {_mod, _fun} = type -> type\n        fun -> {Phoenix.HTML.Form, fun}\n      end\n\n    args = [form, field] ++ opts[:args] ++ [add_class(opts[:attrs], \"form-control\")]\n    apply(mod, fun, args)\n  end\n\n  defp add_class(opts, class) do\n    base_class = Keyword.get(opts, :class, \"\")\n    Keyword.put(opts, :class, base_class <> \" \" <> class)\n  end\nend"},{"coverage":[null,null,null,null,null,128,128,128,null,null,null,null,null,0,null,null,null,null,null,null,null,21,21,21,21,null,null,null,null,null,66,null,null,null,null,null,null,37,null,null,null,null,null,null,15,null,15,null,null,null,null,null,null,6,null,null,null,6,null,null,null,null,48,null,null,null,14,14,14,null,14,null,7,null,7,null,null,14,14,null,null,null,27,27,27,null,27,null,5,null,22,null,null,27,27,null,null,null,21,21,21,null,21,null,7,null,14,null,null,21,21,null,null,null,6,6,null,6,null,0,null,6,null,null,6,6,null,null,null,2,null,null,null,1,1,null,null,null,18,18,null,null,null,18,null,null,null,null,20,6,null,null],"name":"test/support/factory.ex","source":"defmodule Librecov.Factory do\n  use ExMachina\n  use ExMachina.EctoWithChangesetStrategy, repo: Librecov.Repo\n\n  def project_factory do\n    %Librecov.Project{\n      name: sequence(:name, &\"name-#{&1}\"),\n      base_url: sequence(:base_url, &\"https://github.com/tuvistavie/name-#{&1}\"),\n      current_coverage: 50.0\n    }\n  end\n\n  def settings_factory do\n    %Librecov.Settings{\n      signup_enabled: false,\n      restricted_signup_domains: nil,\n      default_project_visibility: \"internal\"\n    }\n  end\n\n  def user_factory do\n    %Librecov.User{\n      id: sequence(:id, &(&1 + 2)),\n      name: sequence(:name, &\"name-#{&1}\"),\n      email: sequence(:email, &\"email-#{&1}@example.com\"),\n      password: \"my-secure-password\"\n    }\n  end\n\n  def build_factory do\n    %Librecov.Build{\n      build_number: sequence(:build_number, & &1),\n      project: build(:project)\n    }\n  end\n\n  def job_factory do\n    %Librecov.Job{\n      job_number: sequence(:job_number, & &1),\n      build: build(:build)\n    }\n  end\n\n  def file_factory do\n    %Librecov.File{\n      job: build(:job),\n      name: sequence(:name, &\"file-#{&1}\"),\n      source: \"return 0\",\n      coverage_lines: []\n    }\n  end\n\n  def badge_factory do\n    %Librecov.Badge{\n      project: build(:project),\n      coverage: 50.0,\n      image: \"encoded_image\",\n      format: to_string(Librecov.Badge.default_format())\n    }\n  end\n\n  def make_changeset(%Librecov.Project{} = project) do\n    Librecov.ProjectManager.changeset(project, %{})\n  end\n\n  def make_changeset(%Librecov.File{} = file) do\n    {job_id, file} = Map.pop(file, :job_id)\n    job_id = job_id || file.job.id\n    params = Map.from_struct(file)\n\n    job =\n      if job_id do\n        Librecov.Repo.get(Librecov.Job, job_id)\n      else\n        insert(:job)\n      end\n\n    file = Ecto.build_assoc(job, :files)\n    Librecov.FileManager.changeset(file, params)\n  end\n\n  def make_changeset(%Librecov.Build{} = build) do\n    {project_id, build} = Map.pop(build, :project_id)\n    project_id = project_id || build.project.id\n    params = Map.from_struct(build)\n\n    project =\n      if project_id do\n        Librecov.Repo.get(Librecov.Project, project_id)\n      else\n        insert(:project)\n      end\n\n    build = Ecto.build_assoc(project, :builds)\n    Librecov.BuildManager.changeset(build, params)\n  end\n\n  def make_changeset(%Librecov.Job{} = job) do\n    {build_id, job} = Map.pop(job, :build_id)\n    build_id = build_id || job.build.id\n    params = Map.from_struct(job)\n\n    build =\n      if build_id do\n        Librecov.Repo.get(Librecov.Build, build_id)\n      else\n        insert(:build)\n      end\n\n    job = Ecto.build_assoc(build, :jobs)\n    Librecov.JobManager.changeset(job, params)\n  end\n\n  def make_changeset(%Librecov.Badge{} = badge) do\n    {project_id, badge} = Map.pop(badge, :project_id)\n    params = Map.from_struct(badge)\n\n    project =\n      if project_id do\n        Librecov.Repo.get(Librecov.Project, project_id)\n      else\n        insert(:project)\n      end\n\n    badge = Ecto.build_assoc(project, :badge)\n    Librecov.BadgeManager.changeset(badge, params)\n  end\n\n  def make_changeset(model) do\n    model\n  end\n\n  def with_project(build) do\n    project = insert(:project)\n    %{build | project_id: project.id}\n  end\n\n  def with_secure_password(user, password) do\n    changeset = Librecov.UserManager.changeset(user, %{password: password})\n    %{user | password_digest: changeset.changes[:password_digest]}\n  end\n\n  def confirmed_user(user) do\n    %{user | confirmed_at: Timex.now(), password_initialized: true}\n  end\n\n  def params_for(factory_name, attrs \\\\ %{}) do\n    ExMachina.Ecto.params_for(__MODULE__, factory_name, attrs)\n    |> Enum.reject(fn {_key, value} -> is_nil(value) or value == \"\" end)\n    |> Enum.into(%{})\n  end\nend"},{"coverage":[null,null,64,null,null,null,82,null,null],"name":"lib/librecov/helpers/authentication.ex","source":"defmodule Librecov.Helpers.Authentication do\n  def current_user(conn) do\n    Map.fetch!(conn.assigns, :current_user)\n  end\n\n  def user_signed_in?(conn) do\n    Map.fetch(conn.assigns, :current_user) != :error\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,1,1,null,null,null,1,1,null,null,null,2,2,null,2,null,null,null,1,null,null,1,null,null,null,null,2,1,null,null,null,1,1,1,null,null,null,2,2,null,2,null,null,null,1,null,null,1,null,null,null,null,1,1,null,null,null,1,null,null,null,3,3,null,null,null,3,null,null],"name":"web/controllers/project_controller.ex","source":"defmodule Librecov.ProjectController do\n  use Librecov.Web, :controller\n\n  import Librecov.Helpers.Authentication\n\n  alias Librecov.Project\n  alias Librecov.ProjectManager\n\n  plug(:scrub_params, \"project\" when action in [:create, :update])\n\n  def index(conn, _params) do\n    projects = Repo.all(Project) |> ProjectManager.preload_latest_build()\n    render(conn, \"index.html\", projects: projects)\n  end\n\n  def new(conn, _params) do\n    changeset = ProjectManager.changeset(%Project{})\n    render(conn, \"new.html\", changeset: changeset)\n  end\n\n  def create(conn, %{\"project\" => project_params}) do\n    project = Ecto.build_assoc(current_user(conn), :projects)\n    changeset = ProjectManager.changeset(project, project_params)\n\n    case Repo.insert(changeset) do\n      {:ok, project} ->\n        conn\n        |> put_flash(:info, \"Project created successfully.\")\n        |> redirect(to: project_path(conn, :show, project))\n\n      {:error, changeset} ->\n        render(conn, \"new.html\", changeset: changeset)\n    end\n  end\n\n  def show(conn, %{\"id\" => id}) do\n    project = Repo.get!(Project, id) |> ProjectManager.preload_recent_builds()\n    render(conn, \"show.html\", project: project)\n  end\n\n  def edit(conn, %{\"id\" => id}) do\n    project = Repo.get!(Project, id)\n    changeset = ProjectManager.changeset(project)\n    render(conn, \"edit.html\", project: project, changeset: changeset)\n  end\n\n  def update(conn, %{\"id\" => id, \"project\" => project_params}) do\n    project = Repo.get!(Project, id)\n    changeset = ProjectManager.changeset(project, project_params)\n\n    case Repo.update(changeset) do\n      {:ok, project} ->\n        conn\n        |> put_flash(:error, \"Project updated successfully.\")\n        |> redirect(to: project_path(conn, :show, project))\n\n      {:error, changeset} ->\n        render(conn, \"edit.html\", project: project, changeset: changeset)\n    end\n  end\n\n  def delete(conn, %{\"id\" => id}) do\n    project = Repo.get!(Project, id)\n    Repo.delete!(project)\n\n    conn\n    |> put_flash(:info, \"Project deleted successfully.\")\n    |> redirect(to: project_path(conn, :index))\n  end\n\n  def badge(conn, %{\"project_id\" => id, \"format\" => format}) do\n    project = Repo.get!(Project, id)\n    {:ok, badge} = Librecov.BadgeManager.get_or_create(project, format)\n\n    conn\n    |> put_resp_content_type(MIME.type(format))\n    |> send_resp(200, badge.image)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,8,3,null,null,null,null,8,null,8,4,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,0,null,3,null,null,null],"name":"web/views/error_helpers.ex","source":"defmodule Librecov.ErrorHelpers do\n  @moduledoc \"\"\"\n  Conveniences for translating and building error messages.\n  \"\"\"\n  use Phoenix.HTML\n\n  @doc \"\"\"\n  Generates tag for inlined form input errors.\n  \"\"\"\n  def error_tag(form, field) do\n    if error = form.errors[field] do\n      content_tag(:span, translate_error(error), class: \"help-block\")\n    end\n  end\n\n  def state_class(form, field) do\n    cond do\n      # The form was not yet submitted\n      !Map.get(form.source, :action) -> \"\"\n      form.errors[field] -> \"has-error\"\n      true -> \"has-success\"\n    end\n  end\n\n  @doc \"\"\"\n  Translates an error message using gettext.\n  \"\"\"\n  def translate_error({msg, opts}) do\n    # Because error messages were defined within Ecto, we must\n    # call the Gettext module passing our Gettext backend. We\n    # also use the \"errors\" domain as translations are placed\n    # in the errors.po file.\n    # Ecto will pass the :count keyword if the error message is\n    # meant to be pluralized.\n    # On your own code and templates, depending on whether you\n    # need the message to be pluralized or not, this could be\n    # written simply as:\n    #\n    #     dngettext \"errors\", \"1 file\", \"%{count} files\", count\n    #     dgettext \"errors\", \"is invalid\"\n    #\n    if count = opts[:count] do\n      Gettext.dngettext(Librecov.Gettext, \"errors\", msg, msg, count, opts)\n    else\n      Gettext.dgettext(Librecov.Gettext, \"errors\", msg, opts)\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,58,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,5,5,null,null,0,null,null,7,null],"name":"web/models/job.ex","source":"defmodule Librecov.Job do\n  use Librecov.Web, :model\n\n  import Ecto.Query\n\n  schema \"jobs\" do\n    field(:coverage, :float, default: 0.0)\n    field(:previous_job_id, :integer)\n    field(:run_at, :utc_datetime_usec)\n    field(:files_count, :integer)\n    field(:job_number, :integer)\n    field(:previous_coverage, :float)\n\n    belongs_to(:build, Librecov.Build)\n    has_one(:previous_job, Librecov.Job)\n    has_many(:files, Librecov.File)\n\n    timestamps()\n  end\n\n  def compute_coverage(job) do\n    lines = Enum.flat_map(job.files, & &1.coverage_lines)\n    Librecov.File.compute_coverage(lines)\n  end\n\n  def for_build(query, %Librecov.Build{id: id}), do: for_build(query, id)\n\n  def for_build(query, build_id) when is_integer(build_id),\n    do: query |> where(build_id: ^build_id)\nend"},{"coverage":[null,null,null,null,null,null,0,null,null,null,0,null,null,null,0,0,null,0,null,null,0,null,null,0,null,null,null,0,null,null,null,0,null,0,null,null],"name":"web/controllers/integration/github_controller.ex","source":"defmodule Librecov.Integration.GithubController do\n  use Librecov.Web, :controller\n\n  alias Librecov.External.GitHub\n\n  def new(conn, _params) do\n    redirect(conn, external: GitHub.OAuth.authorize_url!())\n  end\n\n  def callback(conn, %{\"code\" => code}) do\n    conn =\n      case GitHub.OAuth.get_token(code: code) do\n        {:ok, access_token} ->\n          current_user(conn)\n          |> Librecov.UserManager.github_changeset(access_token.access_token)\n          |> Repo.update!()\n\n          conn\n\n        {:error, error} ->\n          put_flash(conn, :error, \"GitHub failed with the following error: #{inspect(error)}\")\n      end\n\n    redirect(conn, to: integration_path(conn, :show))\n  end\n\n  def delete(conn, _params) do\n    GitHub.Cache.delete_user(current_user(conn))\n\n    current_user(conn)\n    |> Librecov.UserManager.github_changeset(nil)\n    |> Repo.update!()\n\n    redirect(conn, to: integration_path(conn, :show))\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,0,0,0,null,null,null,0,0,null,0,null,null,null,0,null,null,0,null,null,null],"name":"web/controllers/admin/settings_controller.ex","source":"defmodule Librecov.Admin.SettingsController do\n  use Librecov.Web, :controller\n\n  alias Librecov.SettingsManager\n  alias Librecov.Repo\n\n  # plug :scrub_params, \"settings\" when action in [:update]\n\n  def edit(conn, _params) do\n    settings = SettingsManager.get!()\n    changeset = SettingsManager.changeset(settings)\n    render(conn, \"edit.html\", settings: settings, changeset: changeset)\n  end\n\n  def update(conn, %{\"settings\" => settings_params}) do\n    settings = SettingsManager.get!()\n    changeset = SettingsManager.changeset(settings, settings_params)\n\n    case Repo.update(changeset) do\n      {:ok, _settings} ->\n        conn\n        |> put_flash(:info, \"Settings updated successfully.\")\n        |> redirect(to: admin_dashboard_path(conn, :index))\n\n      {:error, changeset} ->\n        render(conn, \"edit.html\", settings: settings, changeset: changeset)\n    end\n  end\nend"},{"coverage":[null,null,0,0,null,null],"name":"lib/librecov/imagemagick.ex","source":"defmodule Librecov.ImageMagick do\n  def convert(args) do\n    command = Application.get_env(:librecov, :imagemagick_convert_path) || \"convert\"\n    System.cmd(command, args)\n  end\nend"},{"coverage":[null,null,null,null,null,null,118,null,null],"name":"test/support/ecto_with_changeset_stragegy.ex","source":"defmodule ExMachina.EctoWithChangesetStrategy do\n  use ExMachina.Strategy, function_name: :insert\n\n  def handle_insert(record, %{repo: repo, factory_module: module}) do\n    record\n    |> module.make_changeset\n    |> repo.insert!\n  end\nend"},{"coverage":[null,null,null,4,null,null,null,null,null,null,null,null,21,null,null],"name":"test/support/manager_case.ex","source":"defmodule Librecov.ManagerCase do\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      alias Librecov.Repo\n      import Librecov.Factory\n      import Librecov.ManagerCase\n    end\n  end\n\n  setup _tags do\n    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Librecov.Repo)\n  end\nend"},{"coverage":[null,null,null,null,null,null,0,null,null,null,18,0,null,18,null,null,null],"name":"lib/librecov/plug/anonymous_only.ex","source":"defmodule Librecov.Plug.AnonymousOnly do\n  import Librecov.Helpers.Authentication\n  import Plug.Conn, only: [halt: 1]\n  import Phoenix.Controller, only: [redirect: 2]\n\n  def init(opts) do\n    Keyword.put_new(opts, :redirect_to, \"/\")\n  end\n\n  def call(conn, opts) do\n    if user_signed_in?(conn) do\n      redirect(conn, to: opts[:redirect_to]) |> halt\n    else\n      conn\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/librecov/endpoint.ex","source":"defmodule Librecov.Endpoint do\n  use Phoenix.Endpoint, otp_app: :librecov\n\n  plug(Plug.Static,\n    at: \"/\",\n    from: :librecov,\n    gzip: false,\n    only: ~w(css fonts images js favicon.ico robots.txt)\n  )\n\n  if code_reloading? do\n    socket(\"/phoenix/live_reload/socket\", Phoenix.LiveReloader.Socket)\n    plug(Phoenix.LiveReloader)\n    plug(Phoenix.CodeReloader)\n  end\n\n  unless Mix.env() == :test do\n    plug(Plug.RequestId)\n    plug(Plug.Logger)\n  end\n\n  plug(Plug.Parsers,\n    parsers: [:urlencoded, :multipart, :json],\n    pass: [\"*/*\"],\n    json_decoder: Jason\n  )\n\n  plug(Plug.MethodOverride)\n  plug(Plug.Head)\n\n  plug(Plug.Session,\n    store: :cookie,\n    key: \"_librecov_key\",\n    signing_salt: \"DBdPx/m/\"\n  )\n\n  plug(Librecov.Router)\nend"},{"coverage":[null,null,null,null,null,null,null,2,1,1,1,null,null],"name":"web/controllers/build_controller.ex","source":"defmodule Librecov.BuildController do\n  use Librecov.Web, :controller\n\n  alias Librecov.Build\n  alias Librecov.FileService\n\n  def show(conn, %{\"id\" => id} = params) do\n    build = Repo.get!(Build, id) |> Repo.preload([:jobs, :project])\n    job_ids = Enum.map(build.jobs, & &1.id)\n    file_params = FileService.files_with_filter(job_ids, params)\n    render(conn, \"show.html\", [{:build, build} | file_params])\n  end\nend"},{"coverage":[null,null,null,null,null,null],"name":"web/views/admin/project_view.ex","source":"defmodule Librecov.Admin.ProjectView do\n  use Librecov.Web, :view\n\n  import Scrivener.HTML\n  alias Librecov.Helpers.Datetime\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,0,0,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,0,0,null,null,null,0,0,0,null,null,null,0,0,null,0,null,0,null,null,null,null,0,null,null,0,null,null,null,null,0,null,0,null,null,0,null,0,null,null,null,0,null,null,null],"name":"web/controllers/admin/user_controller.ex","source":"defmodule Librecov.Admin.UserController do\n  use Librecov.Web, :controller\n\n  import Librecov.Helpers.Authentication\n\n  alias Librecov.UserService\n  alias Librecov.User\n  alias Librecov.UserManager\n  alias Librecov.Repo\n\n  plug(:scrub_params, \"user\" when action in [:create, :update])\n\n  def index(conn, params) do\n    paginator = Repo.paginate(User, params)\n    render(conn, \"index.html\", users: paginator.entries, paginator: paginator)\n  end\n\n  def new(conn, _params) do\n    changeset = UserManager.changeset(%User{})\n    render(conn, \"new.html\", changeset: changeset)\n  end\n\n  def create(conn, %{\"user\" => user_params}) do\n    case UserService.create_user(user_params, invited?: true) do\n      {:ok, user} ->\n        conn\n        |> put_flash(:info, \"User created successfully.\")\n        |> redirect(to: admin_user_path(conn, :show, user))\n\n      {:error, changeset} ->\n        render(conn, \"new.html\", changeset: changeset)\n    end\n  end\n\n  def show(conn, %{\"id\" => id}) do\n    user = Repo.get!(User, id)\n    render(conn, \"show.html\", user: user)\n  end\n\n  def edit(conn, %{\"id\" => id}) do\n    user = Repo.get!(User, id)\n    changeset = UserManager.changeset(user)\n    render(conn, \"edit.html\", user: user, changeset: changeset)\n  end\n\n  def update(conn, %{\"id\" => id, \"user\" => user_params}) do\n    user = Repo.get!(User, id)\n    changeset = UserManager.changeset(user, user_params)\n\n    case Repo.update(changeset) do\n      {:ok, user} ->\n        redirect_path =\n          NavigationHistory.last_path(conn, 1, default: admin_user_path(conn, :show, user))\n\n        conn\n        |> put_flash(:info, \"user updated successfully.\")\n        |> redirect(to: redirect_path)\n\n      {:error, changeset} ->\n        render(conn, \"edit.html\", user: user, changeset: changeset)\n    end\n  end\n\n  def delete(conn, %{\"id\" => id}) do\n    user = Repo.get!(User, id)\n\n    if current_user(conn).id == user.id do\n      conn\n      |> put_flash(:error, \"You cannot delete yourself.\")\n      |> redirect(to: NavigationHistory.last_path(conn, default: admin_user_path(conn, :index)))\n    else\n      Repo.delete!(user)\n\n      conn\n      |> put_flash(:info, \"User deleted successfully.\")\n      |> redirect(to: admin_user_path(conn, :index))\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,0,null,null,0,0,null,null,null,0,null,null,null,null,0,0,null,null,null,0,null,null,null,0,0,null,null,null,null,null,null,null,0,null,null,null],"name":"web/controllers/user_controller.ex","source":"defmodule Librecov.UserController do\n  use Librecov.Web, :controller\n\n  alias Librecov.User\n  alias Librecov.UserManager\n  import Librecov.Helpers.Authentication\n\n  alias Librecov.UserService\n\n  plug(:scrub_params, \"user\" when action in [:create, :update])\n  plug(:check_signup when action in [:new, :create])\n\n  def new(conn, _params) do\n    changeset = UserManager.changeset(%User{})\n    render(conn, \"new.html\", changeset: changeset)\n  end\n\n  def create(conn, %{\"user\" => user_params}) do\n    case UserService.create_user(make_user_params(user_params), invited?: false) do\n      {:ok, _user} ->\n        conn\n        |> put_flash(:info, \"Please confirm your email address.\")\n        |> redirect(to: auth_path(conn, :login))\n\n      {:error, changeset} ->\n        render(conn, \"new.html\", changeset: changeset)\n    end\n  end\n\n  def confirm(conn, %{\"token\" => token}) do\n    case UserService.confirm_user(token) do\n      {:ok, user, message} ->\n        conn\n        |> put_flash(:info, message)\n        |> finalize_confirm(user)\n\n      {:error, err} ->\n        redirect_to_top_with_error(conn, err)\n    end\n  end\n\n  def confirm(conn, _params),\n    do: redirect_to_top_with_error(conn, \"The URL seems wrong, double check your email\")\n\n  defp finalize_confirm(conn, user) do\n    if user.password_initialized do\n      conn |> redirect(to: auth_path(conn, :login))\n    else\n      conn\n      |> Librecov.Authentication.login(user)\n      |> redirect(to: profile_path(conn, :edit_password))\n    end\n  end\n\n  defp redirect_to_top_with_error(conn, err) do\n    redirect_path = if user_signed_in?(conn), do: \"/\", else: auth_path(conn, :login)\n    conn |> put_flash(:error, err) |> redirect(to: redirect_path)\n  end\n\n  defp make_user_params(params) do\n    params |> Map.delete(\"admin\")\n  end\n\n  defp check_signup(conn, _) do\n    if Librecov.SettingsManager.get!().signup_enabled do\n      conn\n    else\n      conn\n      |> put_flash(\n        :info,\n        \"Signup is disabled. Contact your administrator if you need an account.\"\n      )\n      |> redirect(to: auth_path(conn, :login))\n      |> halt\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,1,null,null,null,1,null,null,null,0,null,null,null,0,null,null,null,0,0,null,null,null,null,null,0,0,0,null,null,null,0,null,null,null,0,null,0,null,0,null,null,0,null,null,0,null,null,null],"name":"web/external/github/cache.ex","source":"defmodule Librecov.External.GitHub.Cache do\n  use GenServer\n\n  @ttl 30 * 60\n\n  def start_link do\n    GenServer.start(__MODULE__, [], name: __MODULE__)\n  end\n\n  def init(_args) do\n    {:ok, %{users: %{}}}\n  end\n\n  def save_user(user) do\n    GenServer.cast(__MODULE__, {:save_user, user})\n  end\n\n  def delete_user(user) do\n    GenServer.cast(__MODULE__, {:delete_user, user})\n  end\n\n  def fetch_user(user) do\n    case GenServer.call(__MODULE__, {:fetch_user, user}) do\n      {:ok, github_user} -> github_user\n      :error -> nil\n    end\n  end\n\n  def handle_cast({:save_user, user}, state) do\n    expire = DateTime.to_unix(DateTime.utc_now()) + @ttl\n    new_state = put_in(state, [:users, user.id], {user.github_info, expire})\n    {:noreply, new_state}\n  end\n\n  def handle_cast({:delete_user, user}, state) do\n    {:noreply, pop_in(state, [:users, user.id]) |> elem(1)}\n  end\n\n  def handle_call({:fetch_user, user}, _from, state) do\n    current_timestamp = DateTime.to_unix(DateTime.utc_now())\n\n    case state.users[user.id] do\n      nil ->\n        {:reply, :error, state}\n\n      {_github_user, expires_at} when expires_at < current_timestamp ->\n        {:reply, :error, pop_in(state, [:users, user.id]) |> elem(1)}\n\n      {github_user, expires_at} when expires_at >= current_timestamp ->\n        {:reply, {:ok, github_user}, state}\n    end\n  end\nend"},{"coverage":[null,null,null],"name":"web/views/user_view.ex","source":"defmodule Librecov.UserView do\n  use Librecov.Web, :view\nend"},{"coverage":[null,null,null,null,null],"name":"web/views/admin/dashboard_view.ex","source":"defmodule Librecov.Admin.DashboardView do\n  use Librecov.Web, :view\n\n  alias Librecov.Helpers.Display\nend"},{"coverage":[null,null,null,null,null],"name":"web/views/shared_view.ex","source":"defmodule Librecov.SharedView do\n  use Librecov.Web, :view\n\n  import Librecov.CommonView\nend"},{"coverage":[null,null,null,null,null,24,null,null,null,null,null,null,null,null,null,null,1,null,null,10,null,null,6,null,null,10,null,null,7,null],"name":"web/models/badge.ex","source":"defmodule Librecov.Badge do\n  use Librecov.Web, :model\n\n  import Ecto.Query\n\n  schema \"badges\" do\n    field(:image, :binary)\n    field(:format, :string)\n    field(:coverage, :float)\n\n    belongs_to(:project, Librecov.Project)\n\n    timestamps()\n  end\n\n  def for_project(query, %Librecov.Project{id: project_id}),\n    do: for_project(query, project_id)\n\n  def for_project(query, project_id) when is_integer(project_id),\n    do: query |> where(project_id: ^project_id)\n\n  def with_format(query, format) when is_atom(format),\n    do: with_format(query, Atom.to_string(format))\n\n  def with_format(query, format),\n    do: query |> where(format: ^format)\n\n  def default_format(),\n    do: Application.get_env(:librecov, :badge_format)\nend"},{"coverage":[null,null,null],"name":"web/views/admin/settings_view.ex","source":"defmodule Librecov.Admin.SettingsView do\n  use Librecov.Web, :view\nend"},{"coverage":[null,null,null,null,null,null,18,null,null,null,0,null,null,null,null,null,null],"name":"lib/librecov/authentication.ex","source":"defmodule Librecov.Authentication do\n  import Plug.Conn, only: [put_session: 3, delete_session: 2]\n\n  @user_id_key :user_id\n\n  def login(conn, user) do\n    put_session(conn, user_id_key(), user.id)\n  end\n\n  def logout(conn) do\n    delete_session(conn, user_id_key())\n  end\n\n  def user_id_key() do\n    @user_id_key\n  end\nend"},{"coverage":[null,null,null,null,null,null,null],"name":"web/views/admin/user_view.ex","source":"defmodule Librecov.Admin.UserView do\n  use Librecov.Web, :view\n\n  import Scrivener.HTML\n  alias Librecov.Helpers.Display\n  alias Librecov.Helpers.Datetime\nend"},{"coverage":[null,7,null,null,null,13,null,12,8,5,3,1,null,null,null,null,3,null,null,null,3,null,3,null,2,1,null,null,null,null,4,null,4,null,2,1,null,null,null,null,3,null,3,1,2,null,null,null],"name":"web/views/common_view.ex","source":"defmodule Librecov.CommonView do\n  def format_coverage(num) when is_float(num), do: \"#{Float.round(num, 1)}%\"\n  def format_coverage(_), do: \"NA\"\n\n  def coverage_color(coverage) do\n    cond do\n      is_nil(coverage) -> \"na\"\n      coverage == 0 -> \"none\"\n      coverage < 80 -> \"low\"\n      coverage < 90 -> \"normal\"\n      coverage < 100 -> \"good\"\n      true -> \"great\"\n    end\n  end\n\n  def human_time_ago(datetime) do\n    \"about \" <> Timex.from_now(datetime)\n  end\n\n  def coverage_diff(previous, current) do\n    formatted_diff = abs(current - previous) |> format_coverage\n\n    cond do\n      previous == current -> \"Coverage has not changed.\"\n      previous > current -> \"Coverage has decreased by #{formatted_diff}.\"\n      previous < current -> \"Coverage has increased by #{formatted_diff}.\"\n    end\n  end\n\n  def repository_class(project) do\n    url = project.base_url\n\n    cond do\n      String.contains?(url, \"github.com\") -> \"fa-github\"\n      String.contains?(url, \"bitbucket.org\") -> \"fa-bitbucket\"\n      true -> \"fa-database\"\n    end\n  end\n\n  def commit_link(project, sha) do\n    url = project.base_url\n\n    cond do\n      String.contains?(url, \"bitbucket.org\") -> \"#{url}/commits/#{sha}\"\n      true -> \"#{url}/commit/#{sha}\"\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,0,null,null,2,2,2,null,2,null,null,null,null,2,null,null,2,null,2,null,null,null,null],"name":"web/services/file_service.ex","source":"defmodule Librecov.FileService do\n  use Librecov.Web, :service\n\n  alias Librecov.File\n\n  # FIXME: we should make file distinct by name instead but this is not yet\n  # supported by scrivener\n  def files_with_filter([job | _], params), do: files_with_filter(job, params)\n\n  def files_with_filter(job, params) do\n    filters = Map.get(params, \"filters\", [])\n    order_field = Map.get(params, \"order_field\", \"diff\")\n    order_direction = Map.get(params, \"order_direction\", :desc)\n\n    query =\n      File.for_job(job)\n      |> File.with_filters(filters)\n      |> File.sort_by(order_field, order_direction)\n\n    paginator = query |> Librecov.Repo.paginate(params)\n\n    [\n      filters: filters,\n      paginator: paginator,\n      files: paginator.entries,\n      order: {order_field, order_direction}\n    ]\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,1,1,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,null,null],"name":"web/views/error_view.ex","source":"defmodule Librecov.ErrorView do\n  use Librecov.Web, :view\n\n  def render(\"404.html\", _assigns) do\n    \"Page not found\"\n  end\n\n  def render(\"404.json\", assigns) do\n    message =\n      case assigns.reason do\n        %Ecto.NoResultsError{} -> \"could not find model\"\n        _ -> \"no such path\"\n      end\n\n    %{error: message}\n  end\n\n  def render(\"500.html\", _assigns) do\n    \"Server internal error\"\n  end\n\n  # In case no render clause matches or no\n  # template is found, let's render it as 500\n  def template_not_found(_template, assigns) do\n    render(\"500.html\", assigns)\n  end\nend"},{"coverage":[null,null,null,null,null,null,2,1,1,null,null],"name":"web/controllers/file_controller.ex","source":"defmodule Librecov.FileController do\n  use Librecov.Web, :controller\n\n  alias Librecov.File\n\n  def show(conn, %{\"id\" => id}) do\n    file = Repo.get!(File, id) |> Librecov.Repo.preload(job: [build: :project])\n    file_json = Jason.encode!(file)\n    render(conn, \"show.html\", file: file, file_json: file_json)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,0,0,null,null,null,0,0,null,null],"name":"web/controllers/admin/project_controller.ex","source":"defmodule Librecov.Admin.ProjectController do\n  use Librecov.Web, :controller\n\n  alias Librecov.Project\n  alias Librecov.Repo\n\n  plug(:scrub_params, \"project\" when action in [:create, :update])\n\n  def index(conn, params) do\n    paginator = Repo.paginate(Project, params)\n    render(conn, \"index.html\", projects: paginator.entries, paginator: paginator)\n  end\n\n  def show(conn, %{\"id\" => id}) do\n    project = Repo.get!(Project, id)\n    render(conn, \"show.html\", project: project)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"web/gettext.ex","source":"defmodule Librecov.Gettext do\n  @moduledoc \"\"\"\n  A module providing Internationalization with a gettext-based API.\n  By using [Gettext](https://hexdocs.pm/gettext),\n  your module gains a set of macros for translations, for example:\n      import Librecov.Gettext\n      # Simple translation\n      gettext \"Here is the string to translate\"\n      # Plural translation\n      ngettext \"Here is the string to translate\",\n               \"Here are the strings to translate\",\n               3\n      # Domain-based translation\n      dgettext \"errors\", \"Here is the error message to translate\"\n  See the [Gettext Docs](https://hexdocs.pm/gettext) for detailed usage.\n  \"\"\"\n  use Gettext, otp_app: :librecov\nend"},{"coverage":[null,null,null,null,null,35,31,1,35,35,null],"name":"lib/librecov/types/json.ex","source":"defmodule :map do\n  @behaviour Ecto.Type\n\n  def type, do: :json\n\n  def cast(any), do: {:ok, any}\n  def load(value), do: Jason.decode(value)\n  def dump(value) when is_binary(value), do: {:ok, value}\n  def dump(value), do: Jason.encode(value)\n  def equal?(value, other), do: Jason.encode(value) == Jason.encode(other)\nend"},{"coverage":[null,null,0,0,0,null,null,null,null,null,0,null,null,null,0,null,null],"name":"lib/librecov/helpers/display.ex","source":"defmodule Librecov.Helpers.Display do\n  def display(nil), do: \"-\"\n  def display(value) when is_boolean(value), do: bool(value)\n  def display(value) when is_atom(value), do: atom(value)\n  def display(value) when is_binary(value), do: text(value)\n\n  def bool(true), do: \"✔\"\n  def bool(_), do: \"×\"\n\n  def atom(a) when is_atom(a) do\n    a |> Atom.to_string() |> String.split(\"_\") |> Enum.join(\" \") |> String.capitalize()\n  end\n\n  def text(text) do\n    {:safe, text |> String.split(\"\\n\") |> Enum.join(\"<br>\")}\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null],"name":"lib/librecov/mailer.ex","source":"defmodule Librecov.Mailer do\n  @templates_base_path Path.join(__DIR__, \"../../web/templates/mailers\")\n\n  defmacro __using__(_opts) do\n    quote do\n      require EEx\n      import Librecov.Mailer\n    end\n  end\n\n  defmacro define_template(action, params, format) do\n    quote bind_quoted: [action: action, params: params, format: format] do\n      path = Librecov.Mailer.template_path(__MODULE__, action, format)\n      EEx.function_from_file(:defp, String.to_atom(\"#{action}_#{format}\"), path, params)\n    end\n  end\n\n  defmacro define_html_template(action, params) do\n    quote bind_quoted: [action: action, params: params] do\n      define_template(action, params, \"html\")\n    end\n  end\n\n  defmacro define_text_template(action, params) do\n    quote bind_quoted: [action: action, params: params] do\n      define_template(action, params, \"text\")\n    end\n  end\n\n  defmacro define_templates(action, params) do\n    quote bind_quoted: [action: action, params: params] do\n      define_text_template(action, params)\n      define_html_template(action, params)\n    end\n  end\n\n  def template_path(module, action, format) do\n    Path.join([@templates_base_path, module_path(module), \"#{action}.#{format}.eex\"])\n  end\n\n  defp module_path(module) do\n    module\n    |> Atom.to_string()\n    |> String.replace(~r/^Elixir\\.Librecov\\./, \"\")\n    |> String.replace(\".\", \"/\")\n    |> Macro.underscore()\n    |> String.replace(~r/_mailer$/, \"\")\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,0,null,null,null],"name":"lib/librecov.ex","source":"defmodule Librecov do\n  use Application\n\n  # See http://elixir-lang.org/docs/stable/elixir/Application.html\n  # for more information on OTP Applications\n  def start(_type, _args) do\n    import Supervisor.Spec, warn: false\n\n    children = [\n      # Start the endpoint when the application starts\n      supervisor(Librecov.Endpoint, []),\n      # Start the Ecto repository\n      worker(Librecov.Repo, []),\n      worker(Librecov.External.GitHub.Cache, [])\n      # Here you could define other workers and supervisors as children\n      # worker(Librecov.Worker, [arg1, arg2, arg3]),\n    ]\n\n    # See http://elixir-lang.org/docs/stable/elixir/Supervisor.html\n    # for other strategies and supported options\n    opts = [strategy: :one_for_one, name: Librecov.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\n\n  # Tell Phoenix to update the endpoint configuration\n  # whenever the application is updated.\n  def config_change(changed, _new, removed) do\n    Librecov.Endpoint.config_change(changed, removed)\n    :ok\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,36,null,null,null,20,20,null,null,16,null,null,36,1,35,null,null,null,null,34,null,null,null,1,1,null,null,null,1,null,33,null,null,34,34,null,null,null,1,null,null],"name":"web/managers/file_manager.ex","source":"defmodule Librecov.FileManager do\n  use Librecov.Web, :manager\n  import Librecov.File\n  alias Librecov.File\n\n  @required_fields ~w(name source coverage_lines)a\n  @optional_fields ~w(job_id)a\n\n  def changeset(model, params \\\\ :invalid) do\n    model\n    |> cast(normalize_params(params), @required_fields ++ @optional_fields)\n    |> validate_required(@required_fields)\n    |> generate_coverage\n    |> prepare_changes(&set_previous_file/1)\n  end\n\n  defp normalize_params(%{\"coverage\" => coverage} = params) when is_list(coverage) do\n    {lines, params} = Map.pop(params, \"coverage\")\n    Map.put(params, \"coverage_lines\", lines)\n  end\n\n  defp normalize_params(params), do: params\n\n  defp generate_coverage(changeset) do\n    case get_change(changeset, :coverage_lines) do\n      nil -> changeset\n      lines -> put_change(changeset, :coverage, compute_coverage(lines))\n    end\n  end\n\n  defp set_previous_file(changeset),\n    do: set_previous_file(changeset, job_for_changeset(changeset))\n\n  defp set_previous_file(changeset, %Librecov.Job{previous_job_id: previous_job_id})\n       when not is_nil(previous_job_id) do\n    file = find_previous_file(previous_job_id, changeset.changes.name)\n    set_previous_file(changeset, file)\n  end\n\n  defp set_previous_file(changeset, %Librecov.File{id: id, coverage: coverage}),\n    do: change(changeset, previous_file_id: id, previous_coverage: coverage)\n\n  defp set_previous_file(changeset, _), do: changeset\n\n  defp job_for_changeset(changeset) do\n    job_id = get_change(changeset, :job_id) || changeset.data.job_id\n    Repo.get(Librecov.Job, job_id)\n  end\n\n  defp find_previous_file(previous_job_id, name) do\n    File |> for_job(previous_job_id) |> with_name(name) |> Librecov.Repo.first()\n  end\nend"},{"coverage":[null,null,null,null,null,130,null,null,null,null,null,null,null,null,null,null,null,null,null,63,null,null,null,null,null,null],"name":"web/models/project.ex","source":"defmodule Librecov.Project do\n  use Librecov.Web, :model\n\n  import Ecto.Query\n\n  schema \"projects\" do\n    field(:name, :string)\n    field(:token, :string)\n    field(:current_coverage, :float)\n    field(:base_url, :string)\n\n    belongs_to(:user, Librecov.User)\n    has_many(:builds, Librecov.Build)\n    has_one(:badge, Librecov.Badge)\n\n    timestamps()\n  end\n\n  def with_token(query, token) do\n    query |> where(token: ^token)\n  end\n\n  def visibility_choices do\n    ~w(public private internal)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,20,0,20,null,null,null,null,0,null,null,null,null,0,0,0,null,null,null,null,null,0,2,0,null,2,null,null,null,null,null,0,null,null,null,0,null,null,null,2,null,2,1,1,null,1,null,null,null,null,0,null,null,null,0,null,null,null,20,20,null,20,0,null,20,null,null,null,null,1,null,null,1,null,null,null,null,20,null,null,null,1,null,19,null,null,null,null,1,1,null,1,0,null,null,null,null,22,null,22,21,null,21,20,1,null,1,0,1,null,null,null,null,null,null,22,22,null,null,null,null,null,21,null,null,null,20,null,null,20,null,null,null,1,null,1,null,0,null,null,null,null,21,null,null,0,null,null,1,null,null,1,null,null,null,null,null,null,null,null,null],"name":"web/managers/user_manager.ex","source":"defmodule Librecov.UserManager do\n  use Librecov.Web, :manager\n\n  @required_fields ~w(email)a\n  @optional_fields ~w(admin name password)a\n  @default_secure_password_opts [\n    min_length: 6,\n    required: true\n  ]\n\n  def changeset(model, params \\\\ :invalid, opts \\\\ []) do\n    model\n    |> cast(params, @required_fields ++ @optional_fields)\n    |> validate_required(@required_fields)\n    |> unique_constraint(:email)\n    |> validate_email\n    |> assign_unconfirmed_email\n    |> unique_constraint(:unconfirmed_email)\n    |> pipe_when(opts[:generate_password], generate_password)\n    |> with_secure_password\n  end\n\n  def github_changeset(model, access_token) do\n    Ecto.Changeset.change(model)\n    |> put_change(:github_access_token, access_token)\n  end\n\n  def confirmation_changeset(model) do\n    Ecto.Changeset.change(model)\n    |> put_change(:email, model.unconfirmed_email)\n    |> put_change(:unconfirmed_email, nil)\n    |> pipe_when(is_nil(model.confirmed_at), put_change(:confirmed_at, Timex.now()))\n  end\n\n  def password_update_changeset(model, params \\\\ :invalid, opts \\\\ []) do\n    model\n    |> cast(params, ~w(password password_confirmation current_password)a)\n    |> validate_required(~w(password password_confirmation)a)\n    |> pipe_when(!opts[:skip_password_validation], validate_password_update)\n    |> pipe_when(opts[:remove_reset_token], remove_reset_token)\n    |> put_change(:password_initialized, true)\n    |> with_secure_password\n  end\n\n  def password_reset_changeset(model) do\n    change(model)\n    |> generate_password_reset_token\n    |> put_change(:password_reset_sent_at, Timex.now())\n  end\n\n  defp remove_reset_token(changeset) do\n    change(changeset, password_reset_token: nil, password_reset_sent_at: nil)\n  end\n\n  defp validate_password_update(changeset) do\n    user = changeset.data\n\n    if !user.password_initialized or\n         Librecov.User.authenticate(user, get_change(changeset, :current_password)) do\n      delete_change(changeset, :current_password)\n    else\n      add_error(changeset, :current_password, \"is invalid\")\n    end\n  end\n\n  defp generate_password(changeset) do\n    change(changeset, password: SecureRandom.urlsafe_base64(12), password_initialized: false)\n  end\n\n  defp generate_password_reset_token(changeset) do\n    put_change(changeset, :password_reset_token, SecureRandom.urlsafe_base64(30))\n  end\n\n  defp validate_email(%Ecto.Changeset{} = changeset) do\n    email = get_change(changeset, :email)\n    error = email && validate_email_format(email)\n\n    if email && error do\n      add_error(changeset, :email, error)\n    else\n      changeset\n    end\n  end\n\n  defp validate_email_format(email) do\n    if not Regex.match?(~r/@/, email) do\n      \"the email is not valid\"\n    else\n      validate_domain(email)\n    end\n  end\n\n  defp assign_unconfirmed_email(changeset) do\n    if new_email = get_change(changeset, :email) do\n      changeset\n      |> put_change(:unconfirmed_email, new_email)\n      |> put_change(:confirmation_token, SecureRandom.urlsafe_base64(30))\n      |> delete_change(:email)\n    else\n      changeset\n    end\n  end\n\n  defp validate_domain(email) do\n    allowed_domains = Librecov.SettingsManager.restricted_signup_domains()\n    domain = email |> String.split(\"@\") |> List.last()\n\n    if allowed_domains && domain not in allowed_domains do\n      \"only the following domains are allowed: #{Enum.join(allowed_domains, \",\")}\"\n    end\n  end\n\n  def with_secure_password(changeset, opts \\\\ []) do\n    opts = Keyword.merge(@default_secure_password_opts, opts)\n\n    if has_password(changeset) do\n      changeset = validate_password(changeset, opts)\n\n      if changeset.valid?,\n        do: set_password_digest(changeset),\n        else: changeset\n    else\n      if !opts[:required] || changeset_data_loaded?(changeset),\n        do: changeset,\n        else: add_error(changeset, :password, \"can't be blank\")\n    end\n  end\n\n  defp has_password(%Ecto.Changeset{params: nil}), do: false\n\n  defp has_password(changeset) do\n    password = get_change(changeset, :password)\n    is_binary(password) && String.length(password) > 0\n  end\n\n  defp validate_password(changeset, opts) do\n    changeset\n    |> check_min_length(opts[:min_length])\n    |> validate_confirmation(:password)\n  end\n\n  defp set_password_digest(changeset) do\n    hashed = Comeonin.Bcrypt.hashpwsalt(get_change(changeset, :password))\n\n    changeset\n    |> put_change(:password_digest, hashed)\n  end\n\n  defp changeset_data(changeset) do\n    case changeset do\n      # Ecto v2\n      %{data: data} -> data\n      # Ecto v1\n      %{model: data} -> data\n    end\n  end\n\n  defp check_min_length(changeset, min_length) when is_integer(min_length) do\n    validate_length(changeset, :password, min: min_length)\n  end\n\n  defp check_min_length(changeset, _min_length), do: changeset\n\n  defp changeset_data_loaded?(changeset) do\n    case changeset_data(changeset) do\n      # Backward compatibility\n      %{id: id} ->\n        id\n\n      %{__meta__: %{state: :loaded}} ->\n        true\n\n      _ ->\n        false\n    end\n  end\nend"},{"coverage":[null,null,0,0,null,0,null,null,null,null,0,0,null,0,null,null,null,null,0,0,0,null,null,null,null,null],"name":"web/external/github.ex","source":"defmodule Librecov.External.GitHub do\n  def add_user_info(user) do\n    if user.github_access_token do\n      Map.put(user, :github_info, get_user_info(user))\n    else\n      user\n    end\n  end\n\n  def get_user_info(user) do\n    if github_user = Librecov.External.GitHub.Cache.fetch_user(user) do\n      github_user\n    else\n      fetch_user_info(user)\n    end\n  end\n\n  defp fetch_user_info(user) do\n    github_user = Librecov.External.GitHub.OAuth.get!(\"/user\", user: user)\n    Librecov.External.GitHub.Cache.save_user(Map.put(user, :github_info, github_user))\n    github_user\n  end\n\n  defp make_request do\n  end\nend"},{"coverage":[null,null,null,null,null,null,2,null,null],"name":"web/views/api/v1/job_view.ex","source":"defmodule Librecov.Api.V1.JobView do\n  use Librecov.Web, :view\n\n  @attributes ~w(id project_id build_id coverage)a\n\n  def render(\"show.json\", %{job: job}) do\n    job |> Map.take(@attributes)\n  end\nend"},{"coverage":[null,null,null,null,null,null],"name":"web/views/layout_view.ex","source":"defmodule Librecov.LayoutView do\n  use Librecov.Web, :view\n\n  import Librecov.Helpers.Authentication\n  import Exgravatar\nend"},{"coverage":[null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,0,0,null,0,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,0,null,null,null,0,null,null,null,0,null,0,0,null,null,null,null,null,0,null,null,null,null,null,0,null,null,null,0,null,0,null,null,0,null,null,null],"name":"web/external/github/oauth.ex","source":"defmodule Librecov.External.GitHub.OAuth do\n  use OAuth2.Strategy\n\n  @config Application.get_all_env(:librecov)\n  @gh_config Application.get_env(:librecov, :github)\n\n  def client do\n    OAuth2.Client.new(\n      strategy: __MODULE__,\n      client_id: @gh_config[:client_id],\n      client_secret: @gh_config[:client_secret],\n      redirect_uri: Path.join(@config[:base_url], \"integrations/github/callback\"),\n      site: \"https://api.github.com\",\n      authorize_url: \"https://github.com/login/oauth/authorize\",\n      token_url: \"https://github.com/login/oauth/access_token\"\n    )\n  end\n\n  def authorize_url! do\n    OAuth2.Client.authorize_url!(client(), scope: @gh_config[:scope])\n  end\n\n  # you can pass options to the underlying http library via `opts` parameter\n  def get_token(params \\\\ [], headers \\\\ []) do\n    client = client()\n    body = access_token_body(params)\n    headers = [{\"content-type\", \"application/x-www-form-urlencoded\"} | headers]\n\n    case OAuth2.Request.request(:post, client, client.token_url, body, headers, []) do\n      {:ok, %OAuth2.Response{status_code: 200, body: body}} ->\n        {:ok, OAuth2.AccessToken.new(Plug.Conn.Query.decode(body))}\n\n      {:ok, %OAuth2.Response{status_code: status, body: body}} ->\n        {:error, %{status_code: status, body: body}}\n\n      {:error, _err} = error ->\n        error\n\n      err ->\n        {:error, err}\n    end\n  end\n\n  defp access_token_body(params) do\n    base_params = Map.take(client(), [:client_id, :client_secret])\n\n    params\n    |> Enum.into(%{})\n    |> Map.merge(base_params)\n  end\n\n  def get!(url, opts \\\\ []) do\n    client = make_client(opts)\n\n    OAuth2.Client.get!(client, url, Keyword.get(opts, :headers, []), opts).body\n    |> Jason.decode!()\n  end\n\n  # Strategy Callbacks\n\n  def authorize_url(client, params) do\n    OAuth2.Strategy.AuthCode.authorize_url(client, params)\n  end\n\n  def get_token(client, params, headers) do\n    client\n    |> put_header(\"accept\", \"application/json\")\n    |> OAuth2.Strategy.AuthCode.get_token(params, headers)\n  end\n\n  defp make_client(opts) do\n    case opts[:user] do\n      %{github_access_token: token} when is_binary(token) ->\n        Map.put(client(), :token, OAuth2.AccessToken.new(token))\n\n      _ ->\n        client()\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,2,1,1,null,null],"name":"web/controllers/job_controller.ex","source":"defmodule Librecov.JobController do\n  use Librecov.Web, :controller\n\n  alias Librecov.Job\n  alias Librecov.FileService\n\n  def show(conn, %{\"id\" => id} = params) do\n    job = Repo.get!(Job, id) |> Librecov.Repo.preload(build: :project)\n    file_params = FileService.files_with_filter(job, params)\n    render(conn, \"show.html\", [{:job, job} | file_params])\n  end\nend"},{"coverage":[null,null,0,null,null,null,0,null,null,0,0,null],"name":"lib/librecov/helpers/datetime.ex","source":"defmodule Librecov.Helpers.Datetime do\n  def format(datetime, :short) do\n    Timex.format!(datetime, \"%Y/%m/%d %H:%M\", :strftime)\n  end\n\n  def format(datetime, :dateonly) do\n    Timex.format!(datetime, \"%Y/%m/%d\", :strftime)\n  end\n\n  def format(datetime, _), do: format(datetime)\n  def format(datetime), do: Timex.format!(datetime, \"{ISOz}\")\nend"},{"coverage":[null,null,null,null,null,null,3,3,null,null,null,1,1,null,null,null,1,null,null,null,3,2,2,null,null,null,1,null,null,null,null,null,2,null,null],"name":"web/controllers/api/v1/job_controller.ex","source":"defmodule Librecov.Api.V1.JobController do\n  use Librecov.Web, :controller\n\n  alias Librecov.ProjectManager\n\n  def create(conn, %{\"json\" => json}) do\n    json = Jason.decode!(json)\n    handle_create(conn, json)\n  end\n\n  def create(conn, %{\"json_file\" => %Plug.Upload{path: filepath}}) do\n    json = filepath |> File.read!() |> Jason.decode!()\n    handle_create(conn, json)\n  end\n\n  def create(conn, _) do\n    conn |> bad_request(\"request should have 'json' or 'json_file' parameter\")\n  end\n\n  defp handle_create(conn, %{\"repo_token\" => token} = params) do\n    project = ProjectManager.find_by_token!(token)\n    {:ok, {_, job}} = ProjectManager.add_job!(project, params)\n    render(conn, \"show.json\", job: job)\n  end\n\n  defp handle_create(conn, _) do\n    conn |> bad_request(\"missing 'repo_token' parameter\")\n  end\n\n  defp bad_request(conn, message) do\n    conn\n    |> put_status(400)\n    |> json(%{\"error\" => message})\n  end\nend"},{"coverage":[null,null,null,null,null,null,3,null,null],"name":"web/views/job_view.ex","source":"defmodule Librecov.JobView do\n  use Librecov.Web, :view\n\n  import Librecov.CommonView\n\n  def job_time(job) do\n    job.run_at || job.inserted_at\n  end\nend"},{"coverage":[null,null,0,0,0,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,0,0,null,0,null,null,null,null,0,0,0,null,null,null],"name":"web/mailers/app_mailer.ex","source":"defmodule Librecov.AppMailer do\n  def send(email) do\n    email = %{email | from: sender()}\n    message = generate_message(email)\n    Mailman.Adapter.deliver(mailman_config(), normalize_email(email), message)\n  end\n\n  defp generate_message(email) do\n    Mailman.Render.render(email, %Mailman.EexComposeConfig{})\n  end\n\n  defp normalize_email(email) do\n    %{email | from: extract_address(email.from), to: Enum.map(email.to, &extract_address/1)}\n  end\n\n  defp sender() do\n    mail_config()[:sender]\n  end\n\n  defp mail_config do\n    Application.get_env(:librecov, :email, [])\n  end\n\n  defp mailman_config() do\n    if Mix.env() == :test do\n      %Mailman.TestConfig{}\n    else\n      struct(Mailman.SmtpConfig, mail_config()[:smtp])\n    end\n  end\n\n  defp extract_address(email) do\n    case Regex.run(~r/.*?<(.*?)>/, email) do\n      [_, extracted] -> extracted |> String.trim() |> String.downcase()\n      _ -> email\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null],"name":"web/web.ex","source":"defmodule Librecov.Web do\n  @moduledoc \"\"\"\n  A module that keeps using definitions for controllers,\n  views and so on.\n\n  This can be used in your application as:\n\n      use Librecov.Web, :controller\n      use Librecov.Web, :view\n\n  The definitions below will be executed for every view,\n  controller, etc, so keep them short and clean, focused\n  on imports, uses and aliases.\n\n  Do NOT define functions inside the quoted expressions\n  below.\n  \"\"\"\n\n  def model do\n    quote do\n      use Ecto.Schema\n      use Librecov.Core\n\n      import Ecto.Changeset\n      import Ecto.Query, only: [from: 1, from: 2]\n    end\n  end\n\n  def manager do\n    quote do\n      alias Librecov.Repo\n      use Librecov.Core\n\n      import Ecto.Changeset\n    end\n  end\n\n  def service do\n    quote do\n      alias Librecov.Repo\n    end\n  end\n\n  def controller do\n    quote do\n      use Phoenix.Controller\n\n      alias Librecov.Repo\n      import Ecto.Query, only: [from: 1, from: 2]\n\n      import Librecov.Router.Helpers\n      import Librecov.Helpers.Authentication\n    end\n  end\n\n  def view do\n    quote do\n      use Phoenix.View, root: \"web/templates\"\n\n      # Import convenience functions from controllers\n      import Phoenix.Controller, only: [get_csrf_token: 0, get_flash: 2, view_module: 1]\n\n      # Use all HTML functionality (forms, tags, etc)\n      use Phoenix.HTML\n\n      import Librecov.Router.Helpers\n      import Librecov.ErrorHelpers\n      import Librecov.FormHelpers\n    end\n  end\n\n  def router do\n    quote do\n      use Phoenix.Router\n    end\n  end\n\n  def channel do\n    quote do\n      use Phoenix.Channel\n\n      alias Librecov.Repo\n      import Ecto.Query, only: [from: 1, from: 2]\n    end\n  end\n\n  def mailer do\n    quote do\n      use Librecov.Mailer\n    end\n  end\n\n  @doc \"\"\"\n  When used, dispatch to the appropriate controller/view/etc.\n  \"\"\"\n  defmacro __using__(which) when is_atom(which) do\n    apply(__MODULE__, which, [])\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null],"name":"lib/librecov/core.ex","source":"defmodule Librecov.Core do\n  defmacro __using__(_opts) do\n    quote do\n      import Librecov.Core, only: [pipe_when: 3]\n    end\n  end\n\n  defmacro pipe_when(left, condition, fun) do\n    quote do\n      if Librecov.Core.should_pipe(left, unquote(condition)) do\n        unquote(left) |> unquote(fun)\n      else\n        unquote(left)\n      end\n    end\n  end\n\n  defmacro should_pipe(left, condition) when is_function(condition) do\n    quote do\n      unquote(left) |> unquote(condition)\n    end\n  end\n\n  defmacro should_pipe(_, condition), do: condition\nend"},{"coverage":[null,null,null,null,null,null,1,null,null,null,1,null,null],"name":"web/views/project_view.ex","source":"defmodule Librecov.ProjectView do\n  use Librecov.Web, :view\n\n  import Librecov.CommonView\n\n  def project_badge_path(conn, project) do\n    project_badge_path(conn, :badge, project, Application.get_env(:librecov, :badge_format))\n  end\n\n  def project_badge_url(conn, project) do\n    project_badge_url(conn, :badge, project, Application.get_env(:librecov, :badge_format))\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,0,0,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,0,0,null,null,null,0,0,null,0,null,0,null,null,0,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,0,null,0,0,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,0,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null],"name":"web/controllers/profile_controller.ex","source":"defmodule Librecov.ProfileController do\n  use Librecov.Web, :controller\n\n  alias Librecov.User\n  alias Librecov.UserManager\n\n  def show(conn, _params) do\n    user = current_user(conn)\n    render(conn, \"edit.html\", user: user, changeset: UserManager.changeset(user))\n  end\n\n  def update(conn, params) do\n    case Librecov.UserService.update_user(params, current_user(conn)) do\n      {:ok, _user, redirect_path, flash_message} ->\n        conn\n        |> put_flash(:info, flash_message)\n        |> redirect(to: redirect_path)\n\n      {:error, assigns} ->\n        render(conn, \"edit.html\", assigns)\n    end\n  end\n\n  def edit_password(conn, _params) do\n    user = current_user(conn)\n    render(conn, \"edit_password.html\", user: user, changeset: UserManager.changeset(user))\n  end\n\n  def update_password(conn, %{\"user\" => user_params}) do\n    user = current_user(conn)\n    changeset = UserManager.password_update_changeset(user, user_params)\n\n    case Repo.update(changeset) do\n      {:ok, _user} ->\n        conn |> put_flash(:info, \"Your password has been updated\") |> redirect(to: \"/\")\n\n      {:error, changeset} ->\n        render(conn, \"edit_password.html\", user: user, changeset: changeset)\n    end\n  end\n\n  def reset_password_request(conn, _params) do\n    render(conn, \"reset_password_request.html\")\n  end\n\n  def send_reset_password(conn, %{\"user\" => %{\"email\" => email}}) do\n    Librecov.UserService.send_reset_password(email)\n\n    conn\n    |> put_flash(:info, \"An email has been sent to reset your password.\")\n    |> redirect(to: auth_path(conn, :login))\n  end\n\n  def reset_password(conn, %{\"token\" => token}) do\n    case Repo.get_by(User, password_reset_token: token) do\n      %User{} = user ->\n        changeset = UserManager.changeset(user)\n        render(conn, \"reset_password.html\", user: user, changeset: changeset, token: token)\n\n      _ ->\n        password_reset_error(conn)\n    end\n  end\n\n  def finalize_reset_password(conn, %{\"user\" => %{\"password_reset_token\" => token} = user_params}) do\n    case Librecov.UserService.finalize_reset_password(user_params) do\n      {:ok, user} ->\n        conn\n        |> put_flash(:info, \"Your password has been reset.\")\n        |> Librecov.Authentication.login(user)\n        |> redirect(to: \"/\")\n\n      {:error, :not_found} ->\n        password_reset_error(conn)\n\n      {:error, changeset} ->\n        render(conn, \"reset_password.html\",\n          user: changeset.data,\n          changeset: changeset,\n          token: token\n        )\n    end\n  end\n\n  defp password_reset_error(conn) do\n    conn\n    |> put_flash(\n      :error,\n      \"Could not reset your password. Check your email or try the process again.\"\n    )\n    |> redirect(to: auth_path(conn, :login))\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,56,null,null,null,56,null,null,null,56,56,null,null,null,58,null,null,null,5,null,null,null,4,4,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,1,null,null,1,null,null,null,3,3,3,3,null,null,null],"name":"web/managers/project_manager.ex","source":"defmodule Librecov.ProjectManager do\n  use Librecov.Web, :manager\n  alias Librecov.Project\n  import Librecov.Project\n\n  import Ecto.Query\n\n  @required_fields ~w(name base_url)a\n  @optional_fields ~w(token current_coverage)a\n\n  def changeset(model, params \\\\ :invalid) do\n    model\n    |> cast(params, @required_fields ++ @optional_fields)\n    |> validate_required(@required_fields)\n    |> generate_token\n  end\n\n  def generate_token(changeset) do\n    put_change(changeset, :token, unique_token())\n  end\n\n  defp unique_token() do\n    token = SecureRandom.urlsafe_base64(30)\n    if find_by_token(token), do: unique_token(), else: token\n  end\n\n  def find_by_token(token) do\n    with_token(Project, token) |> Repo.first()\n  end\n\n  def find_by_token!(token) do\n    with_token(Project, token) |> Repo.first!()\n  end\n\n  def update_coverage(project) do\n    coverage = (Librecov.Build.last_for_project(Librecov.Build, project) |> Repo.first!()).coverage\n    Repo.update!(change(project, current_coverage: coverage))\n  end\n\n  def preload_latest_build(projects) do\n    query =\n      from(b in Librecov.Build,\n        join: p in assoc(b, :project),\n        where:\n          b.completed and\n            b.id ==\n              fragment(\n                \"\"\"\n                (SELECT id\n                 FROM builds AS b\n                 WHERE b.project_id = ?\n                 ORDER BY b.inserted_at\n                 DESC LIMIT 1)\n                \"\"\",\n                p.id\n              ),\n        order_by: [desc: b.inserted_at]\n      )\n\n    Librecov.Repo.preload(projects, builds: query)\n  end\n\n  def preload_recent_builds(projects) do\n    query =\n      from(b in Librecov.Build, where: b.completed, order_by: [desc: b.inserted_at], limit: 10)\n\n    Librecov.Repo.preload(projects, builds: query)\n  end\n\n  def add_job!(project, params) do\n    Librecov.Repo.transaction(fn ->\n      build = Librecov.BuildManager.get_or_create!(project, params)\n      job = Librecov.JobManager.create_from_json!(build, params)\n      {build, job}\n    end)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,0,0,null,0,null,0,null,null,null,null,null,null,0,null,null,0,null,0,null,0,null,null,null,null,null,null,0,null],"name":"web/mailers/user_mailer.ex","source":"defmodule Librecov.UserMailer do\n  use Librecov.Web, :mailer\n\n  define_templates(:confirmation, [:user, :base_url, :confirmation_url, :opts])\n  define_templates(:reset_password, [:user, :reset_password_url])\n\n  def confirmation_email(user, opts \\\\ []) do\n    confirmation_url = confirmation_url(user.confirmation_token)\n    subject = if opts[:registration], do: \"Welcome to Librecov\", else: \"Please confirm your email\"\n\n    %Mailman.Email{\n      subject: subject,\n      to: [\"#{user.name} <#{user.unconfirmed_email}>\"],\n      text: confirmation_text(user, Librecov.Endpoint.url(), confirmation_url, opts),\n      html: confirmation_html(user, Librecov.Endpoint.url(), confirmation_url, opts)\n    }\n  end\n\n  defp confirmation_url(token),\n    do: Librecov.Router.Helpers.user_url(Librecov.Endpoint, :confirm, token: token)\n\n  def reset_password_email(user) do\n    reset_password_url = reset_password_url(user.password_reset_token)\n\n    %Mailman.Email{\n      subject: \"Reset your password\",\n      to: [\"#{user.name} <#{user.email}>\"],\n      text: reset_password_text(user, reset_password_url),\n      html: reset_password_html(user, reset_password_url)\n    }\n  end\n\n  defp reset_password_url(token),\n    do: Librecov.Router.Helpers.profile_url(Librecov.Endpoint, :reset_password, token: token)\nend"},{"coverage":[null,null,null,null,0,null,null,0,0,0,null,null,0,null,null],"name":"web/views/auth_view.ex","source":"defmodule Librecov.AuthView do\n  use Librecov.Web, :view\n\n  def initial_value(form, param) do\n    compute_value(param, Map.get(form.params, to_string(param), \"\"), demo?())\n  end\n\n  defp compute_value(_param, value, false), do: value\n  defp compute_value(param, \"\", true), do: Application.get_env(:librecov, :demo)[param]\n  defp compute_value(_param, value, _), do: value\n\n  def demo?() do\n    !!Application.get_env(:librecov, :demo)[:enabled]\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,10,null,null,null,null,null,null,null,null,null,23,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null],"name":"test/support/model_case.ex","source":"defmodule Librecov.ModelCase do\n  @moduledoc \"\"\"\n  This module defines the test case to be used by\n  model tests.\n\n  You may define functions here to be used as helpers in\n  your model tests. See `errors_on/2`'s definition as reference.\n\n  Finally, if the test case interacts with the database,\n  it cannot be async. For this reason, every test runs\n  inside a transaction which is reset at the beginning\n  of the test unless the test case is marked as async.\n  \"\"\"\n\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      alias Librecov.Repo\n      import Ecto.Query, only: [from: 2]\n      import Librecov.Factory\n      import Librecov.ModelCase\n    end\n  end\n\n  setup _tags do\n    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Librecov.Repo)\n  end\n\n  @doc \"\"\"\n  Helper for returning list of errors in model when passed certain data.\n\n  ## Examples\n\n  Given a User model that lists `:name` as a required field and validates\n  `:password` to be safe, it would return:\n\n      iex> errors_on(%User{}, %{password: \"password\"})\n      [password: \"is unsafe\", name: \"is blank\"]\n\n  You could then write your assertion like:\n\n      assert {:password, \"is unsafe\"} in errors_on(%User{}, %{password: \"password\"})\n\n  You can also create the changeset manually and retrieve the errors\n  field directly:\n\n      iex> changeset = UserManager.changeset(%User{}, password: \"password\")\n      iex> {:password, \"is unsafe\"} in changeset.errors\n      true\n  \"\"\"\n  def errors_on(model, data) do\n    model.__struct__.changeset(model, data).errors\n  end\nend"}]}