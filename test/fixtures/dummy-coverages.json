[
  {
    "source_files": [
      {
        "name": "lib/middleware.js",
        "source": "'use strict';\n\nconst _             = require('lodash');\nconst PolicyManager = require('./policy-manager');\nconst assert        = require('assert');\n\nmodule.exports = function (options) {\n  assert(options && options.policies, 'policies are required');\n\n  let policyManager = new PolicyManager(options.policies, options.defaultStrategies);\n\n  return function *(next) {\n    let entities = yield policyManager.applyPolicies(this);\n    _.assign(this.state, entities);\n    yield next;\n  };\n};\n",
        "coverage": [
          null,
          null,
          1,
          1,
          1,
          null,
          1,
          1,
          null,
          1,
          null,
          1,
          4,
          2,
          2,
          null,
          null,
          null
        ]
      },
      {
        "name": "lib/policy-manager.js",
        "source": "'use strict';\n\nconst _                   = require('lodash');\nconst assert              = require('assert');\nconst Policy              = require('./policy');\nconst Executor            = require('./executor');\nconst AuthenticationError = require('./authentication-error');\n\nfunction PolicyManager(policies, defaultStrategies) {\n  if (defaultStrategies) {\n    this._defaultExecutor = new Executor(defaultStrategies);\n  }\n\n  this._policies = [];\n\n  policies = policies || [];\n  assert(_.isArray(policies), 'policies should be an array');\n\n  for (let policy of policies) {\n    this.addPolicy(policy);\n  }\n}\n\n_.extend(PolicyManager.prototype, {\n  policiesFor: function (path, method) {\n    let policies = [];\n    for (let policy of this._policies) {\n      if (policy.appliesTo(path, method)) {\n        policies.push(policy);\n      }\n    }\n    return policies;\n  },\n\n  applyPolicies: function *(context) {\n    let policies = this.policiesFor(context.path, context.method);\n    let entities = {};\n    for (let policy of policies) {\n      if (entities[policy.scope]) {\n        continue;\n      }\n      entities[policy.scope] = yield this.applyPolicy(policy, context);\n    }\n    return entities;\n  },\n\n  applyPolicy: function *(policy, context) {\n    let entity, errMessage;\n    try {\n      entity = yield policy.executor.authenticate(context, policy.scope);\n    } catch (err) {\n      if (err instanceof AuthenticationError) {\n        errMessage = err.message;\n      } else {\n        throw err;\n      }\n    }\n    if (!entity && policy.enforce) {\n      throw new AuthenticationError(errMessage || 'authentication failed', policy);\n    }\n    return entity;\n  },\n\n  addPolicy: function (policy) {\n    if (!(policy instanceof Policy)) {\n      policy = new Policy(policy);\n    }\n    if (policy.strategies) {\n      policy.executor = new Executor(policy.strategies);\n    } else {\n      policy.executor = this._defaultExecutor;\n    }\n    assert(policy.executor,\n      'you must provide a default strategy or a strategy for each policy');\n    this._policies.push(policy);\n  },\n\n  policies: function () {\n    return Object.create(this._policies);\n  }\n});\n\nmodule.exports = PolicyManager;\n",
        "coverage": [
          null,
          null,
          1,
          1,
          1,
          1,
          1,
          null,
          1,
          10,
          10,
          null,
          null,
          10,
          null,
          10,
          10,
          null,
          10,
          2,
          null,
          null,
          null,
          1,
          null,
          15,
          15,
          85,
          16,
          null,
          null,
          15,
          null,
          null,
          null,
          10,
          10,
          10,
          10,
          0,
          null,
          10,
          null,
          4,
          null,
          null,
          null,
          13,
          13,
          13,
          null,
          2,
          1,
          null,
          1,
          null,
          null,
          12,
          6,
          null,
          6,
          null,
          null,
          null,
          65,
          56,
          null,
          65,
          27,
          null,
          38,
          null,
          65,
          null,
          65,
          null,
          null,
          null,
          12,
          null,
          null,
          null,
          1,
          null
        ]
      },
      {
        "name": "lib/policy.js",
        "source": "'use strict';\n\nconst _      = require('lodash');\nconst assert = require('assert');\n\nfunction Policy(policy) {\n  _.assign(this, policy);\n  this._assertValid();\n  this._normalize();\n}\n\n_.extend(Policy.prototype, {\n  _assertValid: function () {\n    assert(_.isUndefined(this.methods) || _.isArray(this.methods),\n      'policy methods must be an array');\n    assert(_.isString(this.path) || _.isRegExp(this.path),\n     'policy path must be a string or a regex');\n    assert(_.isUndefined(this.scope) || _.isString(this.scope),\n     'scope must be a string');\n  },\n\n  _normalize: function () {\n    this.scope = this.scope || 'user';\n    if (_.isUndefined(this.enforce)) {\n      this.enforce = true;\n    }\n  },\n\n  toString: function () {\n    return 'Path: ' + this.path + ', scope: ' + this.scope + ', enforce: ' + this.enforce;\n  },\n\n  appliesTo: function (path, method) {\n    if (this.methods && this.methods.indexOf(method.toUpperCase()) == -1) {\n      return false;\n    }\n    let m = path.match(this.path);\n    return !!m && m.index === 0 && m[0] === path;\n  },\n\n  hasStrategy: function (name) {\n    if (!this.executor) {\n      return false;\n    }\n    return _.some(this.executor.strategies(), {name: name});\n  }\n});\n\nmodule.exports = Policy;\n",
        "coverage": [
          null,
          null,
          1,
          1,
          null,
          1,
          80,
          80,
          78,
          null,
          null,
          1,
          null,
          80,
          null,
          80,
          null,
          78,
          null,
          null,
          null,
          null,
          78,
          78,
          58,
          null,
          null,
          null,
          null,
          7,
          null,
          null,
          null,
          92,
          1,
          null,
          91,
          91,
          null,
          null,
          null,
          2,
          0,
          null,
          2,
          null,
          null,
          null,
          1,
          null
        ]
      },
      {
        "name": "lib/executor.js",
        "source": "'use strict';\n\nconst _      = require('lodash');\nconst assert = require('assert');\n\nfunction Executor(strategies) {\n  this._strategies = [];\n\n  strategies = strategies || [];\n  assert(_.isArray(strategies), 'strategies must be an array');\n\n  for (let strategy of strategies) {\n    this.addStrategy(strategy);\n  }\n}\n\n_.extend(Executor.prototype, {\n  addStrategy: function (strategy) {\n    this._checkModule(strategy);\n    this._strategies.push(strategy);\n  },\n\n  authenticate: function *(context, scope) {\n    for (let module of this._strategies) {\n      let user = yield module.authenticate(context, scope);\n      if (user) {\n        return user;\n      }\n    }\n    return false;\n  },\n\n  strategies: function () {\n    return _.clone(this._strategies);\n  },\n\n  _checkModule: function (module) {\n    assert(module.name, 'strategy must have a name');\n    assert(module.authenticate, 'strategy authenticate method is required');\n    assert(module.authenticate.constructor.name === 'GeneratorFunction',\n      'strategy authenticate method must be a generator function');\n  }\n});\n\nmodule.exports = Executor;\n",
        "coverage": [
          null,
          null,
          1,
          1,
          null,
          1,
          44,
          null,
          44,
          44,
          null,
          44,
          39,
          null,
          null,
          null,
          1,
          null,
          46,
          44,
          null,
          null,
          null,
          16,
          16,
          14,
          3,
          null,
          null,
          11,
          null,
          null,
          null,
          2,
          null,
          null,
          null,
          46,
          44,
          44,
          null,
          null,
          null,
          null,
          1,
          null
        ]
      },
      {
        "name": "lib/authentication-error.js",
        "source": "'use strict';\n\nfunction AuthenticationError(message, policy) {\n  this.message = '';\n  if (policy) {\n    this.message = 'unable to authenticate with policy: ' + policy.toString() + '\\n';\n  }\n  this.message += message;\n  this.policy = policy;\n  this.status = 401;\n}\nAuthenticationError.prototype = Object.create(Error.prototype, {\n  constructor: AuthenticationError.constructor\n});\n\nmodule.exports = AuthenticationError;\n",
        "coverage": [
          null,
          null,
          1,
          8,
          8,
          6,
          null,
          8,
          8,
          8,
          null,
          1,
          null,
          null,
          null,
          1,
          null
        ]
      }
    ],
    "git": {
      "head": {
        "id": "a25a9c2382a3bcc888c83136da50d8d78b9aed6e",
        "author_name": "Daniel Perez",
        "author_email": "daniel@claudetech.com",
        "committer_name": "Daniel Perez",
        "committer_email": "daniel@claudetech.com",
        "message": "Change coveralls endpoint."
      },
      "branch": "main",
      "remotes": [
        {
          "name": "origin",
          "url": "https://github.com/tuvistavie/koa-police.git"
        }
      ]
    },
    "run_at": "2015-10-27T13:17:26.491Z",
    "service_name": "travis-ci",
    "service_job_id": "87664789"
  },
  {
    "source_files": [
      {
        "name": "lib/middleware.js",
        "source": "'use strict';\n\nconst _             = require('lodash');\nconst PolicyManager = require('./policy-manager');\nconst assert        = require('assert');\n\nmodule.exports = function (options) {\n  assert(options && options.policies, 'policies are required');\n\n  let policyManager = new PolicyManager(options.policies, options.defaultStrategies);\n\n  return function *(next) {\n    let entities = yield policyManager.applyPolicies(this);\n    _.assign(this.state, entities);\n    yield next;\n  };\n};\n",
        "coverage": [
          null,
          null,
          1,
          1,
          1,
          null,
          1,
          1,
          null,
          1,
          null,
          1,
          4,
          2,
          2,
          null,
          null,
          null
        ]
      },
      {
        "name": "lib/policy-manager.js",
        "source": "'use strict';\n\nconst _                   = require('lodash');\nconst assert              = require('assert');\nconst Policy              = require('./policy');\nconst Executor            = require('./executor');\nconst AuthenticationError = require('./authentication-error');\n\nfunction PolicyManager(policies, defaultStrategies) {\n  if (defaultStrategies) {\n    this._defaultExecutor = new Executor(defaultStrategies);\n  }\n\n  this._policies = [];\n\n  policies = policies || [];\n  assert(_.isArray(policies), 'policies should be an array');\n\n  for (let policy of policies) {\n    this.addPolicy(policy);\n  }\n}\n\n_.extend(PolicyManager.prototype, {\n  policiesFor: function (path, method) {\n    let policies = [];\n    for (let policy of this._policies) {\n      if (policy.appliesTo(path, method)) {\n        policies.push(policy);\n      }\n    }\n    return policies;\n  },\n\n  applyPolicies: function *(context) {\n    let policies = this.policiesFor(context.path, context.method);\n    let entities = {};\n    for (let policy of policies) {\n      if (entities[policy.scope]) {\n        continue;\n      }\n      entities[policy.scope] = yield this.applyPolicy(policy, context);\n    }\n    return entities;\n  },\n\n  applyPolicy: function *(policy, context) {\n    let entity, errMessage;\n    try {\n      entity = yield policy.executor.authenticate(context, policy.scope);\n    } catch (err) {\n      if (err instanceof AuthenticationError) {\n        errMessage = err.message;\n      } else {\n        throw err;\n      }\n    }\n    if (!entity && policy.enforce) {\n      throw new AuthenticationError(errMessage || 'authentication failed', policy);\n    }\n    return entity;\n  },\n\n  addPolicy: function (policy) {\n    if (!(policy instanceof Policy)) {\n      policy = new Policy(policy);\n    }\n    if (policy.strategies) {\n      policy.executor = new Executor(policy.strategies);\n    } else {\n      policy.executor = this._defaultExecutor;\n    }\n    assert(policy.executor,\n      'you must provide a default strategy or a strategy for each policy');\n    this._policies.push(policy);\n  },\n\n  policies: function () {\n    return Object.create(this._policies);\n  }\n});\n\nmodule.exports = PolicyManager;\n",
        "coverage": [
          null,
          null,
          1,
          1,
          1,
          1,
          1,
          null,
          1,
          10,
          10,
          null,
          null,
          10,
          null,
          10,
          10,
          null,
          10,
          2,
          null,
          null,
          null,
          1,
          null,
          15,
          15,
          85,
          16,
          null,
          null,
          15,
          null,
          null,
          null,
          10,
          10,
          10,
          10,
          0,
          null,
          10,
          null,
          4,
          null,
          null,
          null,
          13,
          13,
          13,
          null,
          2,
          1,
          null,
          1,
          null,
          null,
          12,
          6,
          null,
          6,
          null,
          null,
          null,
          65,
          56,
          null,
          65,
          27,
          null,
          38,
          null,
          65,
          null,
          65,
          null,
          null,
          null,
          12,
          null,
          null,
          null,
          1,
          null
        ]
      },
      {
        "name": "lib/policy.js",
        "source": "'use strict';\n\nconst _      = require('lodash');\nconst assert = require('assert');\n\nfunction Policy(policy) {\n  _.assign(this, policy);\n  this._assertValid();\n  this._normalize();\n}\n\n_.extend(Policy.prototype, {\n  _assertValid: function () {\n    assert(_.isUndefined(this.methods) || _.isArray(this.methods),\n      'policy methods must be an array');\n    assert(_.isString(this.path) || _.isRegExp(this.path),\n     'policy path must be a string or a regex');\n    assert(_.isUndefined(this.scope) || _.isString(this.scope),\n     'scope must be a string');\n  },\n\n  _normalize: function () {\n    this.scope = this.scope || 'user';\n    if (_.isUndefined(this.enforce)) {\n      this.enforce = true;\n    }\n  },\n\n  toString: function () {\n    return 'Path: ' + this.path + ', scope: ' + this.scope + ', enforce: ' + this.enforce;\n  },\n\n  appliesTo: function (path, method) {\n    if (this.methods && this.methods.indexOf(method.toUpperCase()) == -1) {\n      return false;\n    }\n    let m = path.match(this.path);\n    return !!m && m.index === 0 && m[0] === path;\n  },\n\n  hasStrategy: function (name) {\n    if (!this.executor) {\n      return false;\n    }\n    return _.some(this.executor.strategies(), {name: name});\n  }\n});\n\nmodule.exports = Policy;\n",
        "coverage": [
          null,
          null,
          1,
          1,
          null,
          1,
          80,
          80,
          78,
          null,
          null,
          1,
          null,
          80,
          null,
          80,
          null,
          78,
          null,
          null,
          null,
          null,
          78,
          78,
          58,
          null,
          null,
          null,
          null,
          7,
          null,
          null,
          null,
          92,
          1,
          null,
          91,
          91,
          null,
          null,
          null,
          2,
          0,
          null,
          2,
          null,
          null,
          null,
          1,
          null
        ]
      },
      {
        "name": "lib/executor.js",
        "source": "'use strict';\n\nconst _      = require('lodash');\nconst assert = require('assert');\n\nfunction Executor(strategies) {\n  this._strategies = [];\n\n  strategies = strategies || [];\n  assert(_.isArray(strategies), 'strategies must be an array');\n\n  for (let strategy of strategies) {\n    this.addStrategy(strategy);\n  }\n}\n\n_.extend(Executor.prototype, {\n  addStrategy: function (strategy) {\n    this._checkModule(strategy);\n    this._strategies.push(strategy);\n  },\n\n  authenticate: function *(context, scope) {\n    for (let module of this._strategies) {\n      let user = yield module.authenticate(context, scope);\n      if (user) {\n        return user;\n      }\n    }\n    return false;\n  },\n\n  strategies: function () {\n    return _.clone(this._strategies);\n  },\n\n  _checkModule: function (module) {\n    assert(module.name, 'strategy must have a name');\n    assert(module.authenticate, 'strategy authenticate method is required');\n    assert(module.authenticate.constructor.name === 'GeneratorFunction',\n      'strategy authenticate method must be a generator function');\n  }\n});\n\nmodule.exports = Executor;\n",
        "coverage": [
          null,
          null,
          1,
          1,
          null,
          1,
          44,
          null,
          44,
          44,
          null,
          44,
          39,
          null,
          null,
          null,
          1,
          null,
          46,
          44,
          null,
          null,
          null,
          16,
          16,
          14,
          3,
          null,
          null,
          11,
          null,
          null,
          null,
          2,
          null,
          null,
          null,
          46,
          44,
          44,
          null,
          null,
          null,
          null,
          1,
          null
        ]
      },
      {
        "name": "lib/authentication-error.js",
        "source": "'use strict';\n\nfunction AuthenticationError(message, policy) {\n  this.message = '';\n  if (policy) {\n    this.message = 'unable to authenticate with policy: ' + policy.toString() + '\\n';\n  }\n  this.message += message;\n  this.policy = policy;\n  this.status = 401;\n}\nAuthenticationError.prototype = Object.create(Error.prototype, {\n  constructor: AuthenticationError.constructor\n});\n\nmodule.exports = AuthenticationError;\n",
        "coverage": [
          null,
          null,
          1,
          8,
          8,
          6,
          null,
          8,
          8,
          8,
          null,
          1,
          null,
          null,
          null,
          1,
          null
        ]
      }
    ],
    "git": {
      "head": {
        "id": "a25a9c2382a3bcc888c83136da50d8d78b9aed6e",
        "author_name": "Daniel Perez",
        "author_email": "daniel@claudetech.com",
        "committer_name": "Daniel Perez",
        "committer_email": "daniel@claudetech.com",
        "message": "Change coveralls endpoint."
      },
      "branch": "main",
      "remotes": [
        {
          "name": "origin",
          "url": "https://github.com/tuvistavie/koa-police.git"
        }
      ]
    },
    "run_at": "2015-10-27T13:17:26.893Z",
    "service_name": "travis-ci",
    "service_job_id": "87664791"
  },
  {
    "source_files": [
      {
        "name": "lib/middleware.js",
        "source": "'use strict';\n\nconst _             = require('lodash');\nconst PolicyManager = require('./policy-manager');\nconst assert        = require('assert');\n\nmodule.exports = function (options) {\n  assert(options && options.policies, 'policies are required');\n\n  let policyManager = new PolicyManager(options.policies, options.defaultStrategies);\n\n  return function *(next) {\n    let entities = yield policyManager.applyPolicies(this);\n    _.assign(this.state, entities);\n    yield next;\n  };\n};\n",
        "coverage": [
          null,
          null,
          1,
          1,
          1,
          null,
          1,
          1,
          null,
          1,
          null,
          1,
          4,
          2,
          2,
          null,
          null,
          null
        ]
      },
      {
        "name": "lib/policy-manager.js",
        "source": "'use strict';\n\nconst _                   = require('lodash');\nconst assert              = require('assert');\nconst Policy              = require('./policy');\nconst Executor            = require('./executor');\nconst AuthenticationError = require('./authentication-error');\n\nfunction PolicyManager(policies, defaultStrategies) {\n  if (defaultStrategies) {\n    this._defaultExecutor = new Executor(defaultStrategies);\n  }\n\n  this._policies = [];\n\n  policies = policies || [];\n  assert(_.isArray(policies), 'policies should be an array');\n\n  for (let policy of policies) {\n    this.addPolicy(policy);\n  }\n}\n\n_.extend(PolicyManager.prototype, {\n  policiesFor: function (path, method) {\n    let policies = [];\n    for (let policy of this._policies) {\n      if (policy.appliesTo(path, method)) {\n        policies.push(policy);\n      }\n    }\n    return policies;\n  },\n\n  applyPolicies: function *(context) {\n    let policies = this.policiesFor(context.path, context.method);\n    let entities = {};\n    for (let policy of policies) {\n      if (entities[policy.scope]) {\n        continue;\n      }\n      entities[policy.scope] = yield this.applyPolicy(policy, context);\n    }\n    return entities;\n  },\n\n  applyPolicy: function *(policy, context) {\n    let entity, errMessage;\n    try {\n      entity = yield policy.executor.authenticate(context, policy.scope);\n    } catch (err) {\n      if (err instanceof AuthenticationError) {\n        errMessage = err.message;\n      } else {\n        throw err;\n      }\n    }\n    if (!entity && policy.enforce) {\n      throw new AuthenticationError(errMessage || 'authentication failed', policy);\n    }\n    return entity;\n  },\n\n  addPolicy: function (policy) {\n    if (!(policy instanceof Policy)) {\n      policy = new Policy(policy);\n    }\n    if (policy.strategies) {\n      policy.executor = new Executor(policy.strategies);\n    } else {\n      policy.executor = this._defaultExecutor;\n    }\n    assert(policy.executor,\n      'you must provide a default strategy or a strategy for each policy');\n    this._policies.push(policy);\n  },\n\n  policies: function () {\n    return Object.create(this._policies);\n  }\n});\n\nmodule.exports = PolicyManager;\n",
        "coverage": [
          null,
          null,
          1,
          1,
          1,
          1,
          1,
          null,
          1,
          10,
          10,
          null,
          null,
          10,
          null,
          10,
          10,
          null,
          10,
          2,
          null,
          null,
          null,
          1,
          null,
          15,
          15,
          85,
          16,
          null,
          null,
          15,
          null,
          null,
          null,
          10,
          10,
          10,
          10,
          0,
          null,
          10,
          null,
          4,
          null,
          null,
          null,
          13,
          13,
          13,
          null,
          2,
          1,
          null,
          1,
          null,
          null,
          12,
          6,
          null,
          6,
          null,
          null,
          null,
          65,
          56,
          null,
          65,
          27,
          null,
          38,
          null,
          65,
          null,
          65,
          null,
          null,
          null,
          12,
          null,
          null,
          null,
          1,
          null
        ]
      },
      {
        "name": "lib/policy.js",
        "source": "'use strict';\n\nconst _      = require('lodash');\nconst assert = require('assert');\n\nfunction Policy(policy) {\n  _.assign(this, policy);\n  this._assertValid();\n  this._normalize();\n}\n\n_.extend(Policy.prototype, {\n  _assertValid: function () {\n    assert(_.isUndefined(this.methods) || _.isArray(this.methods),\n      'policy methods must be an array');\n    assert(_.isString(this.path) || _.isRegExp(this.path),\n     'policy path must be a string or a regex');\n    assert(_.isUndefined(this.scope) || _.isString(this.scope),\n     'scope must be a string');\n  },\n\n  _normalize: function () {\n    this.scope = this.scope || 'user';\n    if (_.isUndefined(this.enforce)) {\n      this.enforce = true;\n    }\n  },\n\n  toString: function () {\n    return 'Path: ' + this.path + ', scope: ' + this.scope + ', enforce: ' + this.enforce;\n  },\n\n  appliesTo: function (path, method) {\n    if (this.methods && this.methods.indexOf(method.toUpperCase()) == -1) {\n      return false;\n    }\n    let m = path.match(this.path);\n    return !!m && m.index === 0 && m[0] === path;\n  },\n\n  hasStrategy: function (name) {\n    if (!this.executor) {\n      return false;\n    }\n    return _.some(this.executor.strategies(), {name: name});\n  }\n});\n\nmodule.exports = Policy;\n",
        "coverage": [
          null,
          null,
          1,
          1,
          null,
          1,
          80,
          80,
          78,
          null,
          null,
          1,
          null,
          80,
          null,
          80,
          null,
          78,
          null,
          null,
          null,
          null,
          78,
          78,
          58,
          null,
          null,
          null,
          null,
          7,
          null,
          null,
          null,
          92,
          1,
          null,
          91,
          91,
          null,
          null,
          null,
          2,
          0,
          null,
          2,
          null,
          null,
          null,
          1,
          null
        ]
      },
      {
        "name": "lib/executor.js",
        "source": "'use strict';\n\nconst _      = require('lodash');\nconst assert = require('assert');\n\nfunction Executor(strategies) {\n  this._strategies = [];\n\n  strategies = strategies || [];\n  assert(_.isArray(strategies), 'strategies must be an array');\n\n  for (let strategy of strategies) {\n    this.addStrategy(strategy);\n  }\n}\n\n_.extend(Executor.prototype, {\n  addStrategy: function (strategy) {\n    this._checkModule(strategy);\n    this._strategies.push(strategy);\n  },\n\n  authenticate: function *(context, scope) {\n    for (let module of this._strategies) {\n      let user = yield module.authenticate(context, scope);\n      if (user) {\n        return user;\n      }\n    }\n    return false;\n  },\n\n  strategies: function () {\n    return _.clone(this._strategies);\n  },\n\n  _checkModule: function (module) {\n    assert(module.name, 'strategy must have a name');\n    assert(module.authenticate, 'strategy authenticate method is required');\n    assert(module.authenticate.constructor.name === 'GeneratorFunction',\n      'strategy authenticate method must be a generator function');\n  }\n});\n\nmodule.exports = Executor;\n",
        "coverage": [
          null,
          null,
          1,
          1,
          null,
          1,
          44,
          null,
          44,
          44,
          null,
          44,
          39,
          null,
          null,
          null,
          1,
          null,
          46,
          44,
          null,
          null,
          null,
          16,
          16,
          14,
          3,
          null,
          null,
          11,
          null,
          null,
          null,
          2,
          null,
          null,
          null,
          46,
          44,
          44,
          null,
          null,
          null,
          null,
          1,
          null
        ]
      },
      {
        "name": "lib/authentication-error.js",
        "source": "'use strict';\n\nfunction AuthenticationError(message, policy) {\n  this.message = '';\n  if (policy) {\n    this.message = 'unable to authenticate with policy: ' + policy.toString() + '\\n';\n  }\n  this.message += message;\n  this.policy = policy;\n  this.status = 401;\n}\nAuthenticationError.prototype = Object.create(Error.prototype, {\n  constructor: AuthenticationError.constructor\n});\n\nmodule.exports = AuthenticationError;\n",
        "coverage": [
          null,
          null,
          1,
          8,
          8,
          6,
          null,
          8,
          8,
          8,
          null,
          1,
          null,
          null,
          null,
          1,
          null
        ]
      }
    ],
    "git": {
      "head": {
        "id": "a25a9c2382a3bcc888c83136da50d8d78b9aed6e",
        "author_name": "Daniel Perez",
        "author_email": "daniel@claudetech.com",
        "committer_name": "Daniel Perez",
        "committer_email": "daniel@claudetech.com",
        "message": "Change coveralls endpoint."
      },
      "branch": "main",
      "remotes": [
        {
          "name": "origin",
          "url": "https://github.com/tuvistavie/koa-police.git"
        }
      ]
    },
    "run_at": "2015-10-27T13:17:28.033Z",
    "service_name": "travis-ci",
    "service_job_id": "87664792"
  },
  {
    "source_files": [
      {
        "name": "lib/middleware.js",
        "source": "'use strict';\n\nconst _             = require('lodash');\nconst PolicyManager = require('./policy-manager');\nconst assert        = require('assert');\n\nmodule.exports = function (options) {\n  assert(options && options.policies, 'policies are required');\n\n  let policyManager = new PolicyManager(options.policies, options.defaultStrategies);\n\n  return function *(next) {\n    let entities = yield policyManager.applyPolicies(this);\n    _.assign(this.state, entities);\n    yield next;\n  };\n};\n",
        "coverage": [
          null,
          null,
          1,
          1,
          1,
          null,
          1,
          1,
          null,
          1,
          null,
          1,
          4,
          2,
          2,
          null,
          null,
          null
        ]
      },
      {
        "name": "lib/policy-manager.js",
        "source": "'use strict';\n\nconst _                   = require('lodash');\nconst assert              = require('assert');\nconst Policy              = require('./policy');\nconst Executor            = require('./executor');\nconst AuthenticationError = require('./authentication-error');\n\nfunction PolicyManager(policies, defaultStrategies) {\n  if (defaultStrategies) {\n    this._defaultExecutor = new Executor(defaultStrategies);\n  }\n\n  this._policies = [];\n\n  policies = policies || [];\n  assert(_.isArray(policies), 'policies should be an array');\n\n  for (let policy of policies) {\n    this.addPolicy(policy);\n  }\n}\n\n_.extend(PolicyManager.prototype, {\n  policiesFor: function (path, method) {\n    let policies = [];\n    for (let policy of this._policies) {\n      if (policy.appliesTo(path, method)) {\n        policies.push(policy);\n      }\n    }\n    return policies;\n  },\n\n  applyPolicies: function *(context) {\n    let policies = this.policiesFor(context.path, context.method);\n    let entities = {};\n    for (let policy of policies) {\n      if (entities[policy.scope]) {\n        continue;\n      }\n      entities[policy.scope] = yield this.applyPolicy(policy, context);\n    }\n    return entities;\n  },\n\n  applyPolicy: function *(policy, context) {\n    let entity, errMessage;\n    try {\n      entity = yield policy.executor.authenticate(context, policy.scope);\n    } catch (err) {\n      if (err instanceof AuthenticationError) {\n        errMessage = err.message;\n      } else {\n        throw err;\n      }\n    }\n    if (!entity && policy.enforce) {\n      throw new AuthenticationError(errMessage || 'authentication failed', policy);\n    }\n    return entity;\n  },\n\n  addPolicy: function (policy) {\n    if (!(policy instanceof Policy)) {\n      policy = new Policy(policy);\n    }\n    if (policy.strategies) {\n      policy.executor = new Executor(policy.strategies);\n    } else {\n      policy.executor = this._defaultExecutor;\n    }\n    assert(policy.executor,\n      'you must provide a default strategy or a strategy for each policy');\n    this._policies.push(policy);\n  },\n\n  policies: function () {\n    return Object.create(this._policies);\n  }\n});\n\nmodule.exports = PolicyManager;\n",
        "coverage": [
          null,
          null,
          1,
          1,
          1,
          1,
          1,
          null,
          1,
          10,
          10,
          null,
          null,
          10,
          null,
          10,
          10,
          null,
          10,
          2,
          null,
          null,
          null,
          1,
          null,
          15,
          15,
          85,
          16,
          null,
          null,
          15,
          null,
          null,
          null,
          10,
          10,
          10,
          10,
          0,
          null,
          10,
          null,
          4,
          null,
          null,
          null,
          13,
          13,
          13,
          null,
          2,
          1,
          null,
          1,
          null,
          null,
          12,
          6,
          null,
          6,
          null,
          null,
          null,
          65,
          56,
          null,
          65,
          27,
          null,
          38,
          null,
          65,
          null,
          65,
          null,
          null,
          null,
          12,
          null,
          null,
          null,
          1,
          null
        ]
      },
      {
        "name": "lib/policy.js",
        "source": "'use strict';\n\nconst _      = require('lodash');\nconst assert = require('assert');\n\nfunction Policy(policy) {\n  _.assign(this, policy);\n  this._assertValid();\n  this._normalize();\n}\n\n_.extend(Policy.prototype, {\n  _assertValid: function () {\n    assert(_.isUndefined(this.methods) || _.isArray(this.methods),\n      'policy methods must be an array');\n    assert(_.isString(this.path) || _.isRegExp(this.path),\n     'policy path must be a string or a regex');\n    assert(_.isUndefined(this.scope) || _.isString(this.scope),\n     'scope must be a string');\n  },\n\n  _normalize: function () {\n    this.scope = this.scope || 'user';\n    if (_.isUndefined(this.enforce)) {\n      this.enforce = true;\n    }\n  },\n\n  toString: function () {\n    return 'Path: ' + this.path + ', scope: ' + this.scope + ', enforce: ' + this.enforce;\n  },\n\n  appliesTo: function (path, method) {\n    if (this.methods && this.methods.indexOf(method.toUpperCase()) == -1) {\n      return false;\n    }\n    let m = path.match(this.path);\n    return !!m && m.index === 0 && m[0] === path;\n  },\n\n  hasStrategy: function (name) {\n    if (!this.executor) {\n      return false;\n    }\n    return _.some(this.executor.strategies(), {name: name});\n  }\n});\n\nmodule.exports = Policy;\n",
        "coverage": [
          null,
          null,
          1,
          1,
          null,
          1,
          80,
          80,
          78,
          null,
          null,
          1,
          null,
          80,
          null,
          80,
          null,
          78,
          null,
          null,
          null,
          null,
          78,
          78,
          58,
          null,
          null,
          null,
          null,
          7,
          null,
          null,
          null,
          92,
          1,
          null,
          91,
          91,
          null,
          null,
          null,
          2,
          0,
          null,
          2,
          null,
          null,
          null,
          1,
          null
        ]
      },
      {
        "name": "lib/executor.js",
        "source": "'use strict';\n\nconst _      = require('lodash');\nconst assert = require('assert');\n\nfunction Executor(strategies) {\n  this._strategies = [];\n\n  strategies = strategies || [];\n  assert(_.isArray(strategies), 'strategies must be an array');\n\n  for (let strategy of strategies) {\n    this.addStrategy(strategy);\n  }\n}\n\n_.extend(Executor.prototype, {\n  addStrategy: function (strategy) {\n    this._checkModule(strategy);\n    this._strategies.push(strategy);\n  },\n\n  authenticate: function *(context, scope) {\n    for (let module of this._strategies) {\n      let user = yield module.authenticate(context, scope);\n      if (user) {\n        return user;\n      }\n    }\n    return false;\n  },\n\n  strategies: function () {\n    return _.clone(this._strategies);\n  },\n\n  _checkModule: function (module) {\n    assert(module.name, 'strategy must have a name');\n    assert(module.authenticate, 'strategy authenticate method is required');\n    assert(module.authenticate.constructor.name === 'GeneratorFunction',\n      'strategy authenticate method must be a generator function');\n  }\n});\n\nmodule.exports = Executor;\n",
        "coverage": [
          null,
          null,
          1,
          1,
          null,
          1,
          44,
          null,
          44,
          44,
          null,
          44,
          39,
          null,
          null,
          null,
          1,
          null,
          46,
          44,
          null,
          null,
          null,
          16,
          16,
          14,
          3,
          null,
          null,
          11,
          null,
          null,
          null,
          2,
          null,
          null,
          null,
          46,
          44,
          44,
          null,
          null,
          null,
          null,
          1,
          null
        ]
      },
      {
        "name": "lib/authentication-error.js",
        "source": "'use strict';\n\nfunction AuthenticationError(message, policy) {\n  this.message = '';\n  if (policy) {\n    this.message = 'unable to authenticate with policy: ' + policy.toString() + '\\n';\n  }\n  this.message += message;\n  this.policy = policy;\n  this.status = 401;\n}\nAuthenticationError.prototype = Object.create(Error.prototype, {\n  constructor: AuthenticationError.constructor\n});\n\nmodule.exports = AuthenticationError;\n",
        "coverage": [
          null,
          null,
          1,
          8,
          8,
          6,
          null,
          8,
          8,
          8,
          null,
          1,
          null,
          null,
          null,
          1,
          null
        ]
      }
    ],
    "git": {
      "head": {
        "id": "a25a9c2382a3bcc888c83136da50d8d78b9aed6e",
        "author_name": "Daniel Perez",
        "author_email": "daniel@claudetech.com",
        "committer_name": "Daniel Perez",
        "committer_email": "daniel@claudetech.com",
        "message": "Change coveralls endpoint."
      },
      "branch": "main",
      "remotes": [
        {
          "name": "origin",
          "url": "https://github.com/tuvistavie/koa-police.git"
        }
      ]
    },
    "run_at": "2015-10-27T13:17:37.422Z",
    "service_name": "travis-ci",
    "service_job_id": "87664790"
  }
]
